---
title: "EuPPollNet: A European database of plant-pollinator networks"
format:
  pdf:
    include-in-header: 
      text: |
        \usepackage{lscape}
        \newcommand{\blandscape}{\begin{landscape}}
        \newcommand{\elandscape}{\end{landscape}}
        \usepackage{caption}
        \captionsetup[figure]{labelformat=empty}
        \captionsetup[table]{labelformat=empty}

bibliography: references.bib
latex-tinytex: false
link-citations: TRUE
linkcolor: RoyalBlue
urlcolor: RoyalBlue
---

```{r Load libraries, echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE}
library(dplyr) #For handling fata 
library(sf) #For handling coordinates and plotting
library(scales) #For plotting (decimals on axes)
library(lubridate) #To operate with dates
library(tidyr) #Reshape data (wide format)
library(stringr) #Fix/modify strings
library(forcats)
library(readr)
library(phytools)
#Load libraries for plotting
library(giscoR) #Maps
library(ggstar) #cool shapes as points
library(ggplot2) #general plotting
library(ggtree) #phylo trees
library(ggpattern) #cool shapes in barplots
library(patchwork) #plot organisation
library(cowplot) #plot organisation
library(viridis) #colours
library(ggnewscale)
library(ggtreeExtra)
library(kableExtra)

#In case of conflicts select the main dplyr functions
library(conflicted)
conflicts_prefer(dplyr::filter)
conflicts_prefer(dplyr::select)

```

```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE}

#Read data
data = readRDS("../Data/Working_files/Interactions_uncounted.rds")%>% 
mutate(Network_id = paste0(Study_id, Network_id))  

#Bee-syrphid Masterlist
master_list = read_csv("../Data/Species_taxonomy/Thesaurus/Master_bees_syrphids.csv")
#Load butterfly masterlist
master_list1 <- read.delim(file = "../Data/Species_taxonomy/Thesaurus/Butterfly_taxon.txt",
                    header = T)
#Prepare table with data structure (as it would be made available to others)
safenet_database = readRDS("../Data/3_Final_data/Interaction_data.rds")


#Work around to get the three cols
#Note that month 1 and day 1 indicates the presence of a missing value
#At least in Europe :)
data = data %>%
dplyr::mutate(Year = lubridate::year(Date), 
                Month = lubridate::month(Date), 
                Day = lubridate::day(Date))

#Country number
country_number = data %>% 
select(Country) %>% 
n_distinct()
#Study number
study_number = data %>% 
select(Study_id) %>% 
n_distinct()
#Average study number
studies_by_country = data %>% 
group_by(Country) %>% 
summarise(study_number = n_distinct(Study_id)) %>% 
summarise(mean(study_number)) %>% 
pull()
#$\bar{x}_\frac{studies}{country}$ = `r studies_by_country`
#Sampling method
Sampling_method = data %>% 
group_by(Study_id) %>% 
distinct(Sampling_method) %>%  
ungroup() %>% 
count(Sampling_method) %>% 
mutate(percent_method = n/sum(n) *100) %>% 
mutate(Sampling_method = recode_factor(Sampling_method, "Transect" = "transects"))
#1st most common sampling methodology
most_common_method = Sampling_method %>% 
filter(percent_method == max(percent_method)) 
#Minimum year
min_year = data %>% 
select(Year) %>% 
slice(which.min(Year)) %>% 
pull()
#Maximum year
max_year = data %>% 
select(Year) %>% 
slice(which.max(Year)) %>% 
pull()
#Number of interactions
interaction_number = nrow(data)
#Check number of accepted pollinators
pollinator_spp_number = data %>% 
select(Pollinator_rank, Pollinator_accepted_name)%>%
filter(Pollinator_rank == "SPECIES") %>% 
select(Pollinator_accepted_name) %>% 
n_distinct()
#Check number of plant species
plant_spp_number = data %>% 
select(Plant_rank, Plant_status, 
Plant_matchtype, Plant_accepted_name) %>% 
filter(Plant_rank == "SPECIES") %>% 
select(Plant_accepted_name) %>% 
n_distinct()
#Extract percentage of studies conducted during a single year
dates = data %>% 
select(Study_id, Network_id,Sampling_method, Day, Month, Year) %>% 
mutate(Date = dmy(paste(Day, Month, Year, sep = "-"))) %>% 
group_by(Study_id) %>% 
summarise(Count = n_distinct(Year))
#Filter studies with only one year
one_year = dates %>% 
filter(Count == 1) %>% 
pull() %>% 
length() / nrow(dates) * 100
#Obtain date information
dates = data %>% 
select(Study_id, Network_id,Sampling_method, Day, Month, Year) %>% 
mutate(Date = dmy(paste(Day, Month, Year, sep = "-")))

dates1 = dates %>% 
group_by(Study_id, Network_id, Sampling_method) %>% 
summarise(Min_date = min(Date), 
          Max_date= max(Date), 
          Sampling_days = n_distinct(Date)) %>% 
mutate(Sampling_period = as.numeric(Max_date - Min_date)) %>% 
mutate(Study_number = as.integer(str_extract(Study_id, "[^_]+")), 
       .before=Study_id) %>% 
arrange(Study_number) %>% 
mutate(Sampling_period = case_when(!is.na(Sampling_period) ~ Sampling_period + 1,
TRUE ~ NA)) %>% 
mutate(Sampling_days = case_when(!is.na(Sampling_period) ~ Sampling_days,
TRUE ~ NA))
#Extract min and max number of sampling days
min_sampling_day = dates1 %>% pull(Sampling_days) %>% min(na.rm = TRUE)
max_sampling_day = dates1 %>% pull(Sampling_days) %>% max(na.rm = TRUE)
#Extract average of sampling days across networks and studies
average_sampling_days = dates1 %>% 
ungroup() %>% 
group_by(Study_id) %>% 
summarise(mean_sampling_days = mean(Sampling_days, na.rm = TRUE)) %>% 
ungroup() %>% 
summarise(mean(mean_sampling_days, na.rm = TRUE)) %>% 
pull()

#Check number of distinct networks
n_networks = data %>% 
mutate(Network_id = paste0(Network_id,"_", Year)) %>% 
distinct(Network_id) %>% 
nrow(.)

#Check number of distinct sampling sites
n_sites = data %>% 
select(Latitude, Longitude) %>% 
distinct() %>% 
nrow(.)
#Check number of distinct bioregions
n_bioregion = data %>% 
select(Bioregion) %>% 
distinct()  %>% 
nrow(.)
#Read author list 
authors = readr::read_csv("../Data/Manuscript_info/Authorship_ordered.csv")
#Print authors
authors = authors %>% 
summarise(col = paste(Coauthor_name_aff, collapse="| ")) %>% 
pull()
#Read affiliation list 
aff_list = readr::read_csv("../Data/Manuscript_info/Affiliation_list.csv")
aff_list = aff_list %>% 
summarise(col = paste0(Aff_number_Aff, "\\",sep="")) %>% 
pull()

#Interactions at species level
species_level = data %>% 
filter(Plant_rank == "SPECIES") %>% 
filter(Pollinator_rank == "SPECIES") %>% 
filter(Plant_status == "ACCEPTED") %>% 
filter(Pollinator_status == "ACCEPTED") %>% 
nrow(.)
species_level_int = species_level / nrow(data) * 100
#Read here plant and pollinator coverage
bee_coverage = readRDS("../Data/Manuscript_info/bee_coverage.RData")
lepidoptera_coverage = readRDS("../Data/Manuscript_info/lepidoptera_coverage.RData")
syrphid_coverage = readRDS("../Data/Manuscript_info/syrphid_coverage.RData")
plant_coverage = readRDS("../Data/Manuscript_info/plant_coverage.RData")

#Calculate mean coverage and deviation
coverage = c(bee_coverage, syrphid_coverage, lepidoptera_coverage)
mean_coverage = mean(coverage)
sd_coverage = sd(coverage)

#Main orders percentage
o = c("Hymenoptera", "Lepidoptera", "Diptera", "Coleoptera")
main_orders = data %>% 
filter(Pollinator_order %in% o)
main_orders_percent = nrow(main_orders) / nrow(data) * 100

#Prepare table with all info 
#Create variables
vars = colnames(safenet_database)
#Create table
d = tibble(Variable = vars)

d = d %>% 
mutate(Variable = str_replace(Variable, "Latitude", "Latitude-Longitude")) %>% 
filter(!Variable == "Longitude")

#Add descriptor
my_tibble = d %>%
  mutate(Description = case_when(
    Variable == "Study_id" ~ "Identifier of the study",
    Variable == "Network_id" ~ "Identifier of a site sampled within a study",
    Variable == "Sampling_method" ~ "Type of plant-pollinator sampling",
    Variable == "Authors_habitat" ~ "Type of habitat as described by the authors",
    Variable == "EuPPollNet_habitat" ~ "Type of habitat homogenized across studies",
    Variable == "Bioregion" ~ "European biogiographical regions",
    Variable == "Country" ~ "Country where the plant-pollinator interaction was observed",
    Variable == "Locality" ~ "Locality where the plant-pollinator interaction was observed",
    Variable == "Latitude-Longitude" ~ "Coordinates of the observed interaction in decimal degrees",
    Variable == "Date" ~ "Year, month and day when the observation took place",
    Variable == "Interaction" ~ "Number of interactions. By default is 1 as interactions are provided ungrouped",
    Variable == "Plant_original_name" ~ "Plant species name given by the authors",
    Variable == "Plant_accepted_name" ~ "Harmonized plant species name in the database",
    Variable == "Plant_rank" ~ "Taxonomic rank of the observation",
    Variable == "Plant_order" ~ "Order taxonomic rank of the observed plant species",
    Variable == "Plant_family" ~ "Family taxonomic rank of the observed plant species",
    Variable == "Plant_genus" ~ "Genus taxonomic rank of the observed plant species",
    Variable == "Plant_unsure_id" ~ "Category to indicate if the plant species name is unsure (Yes) or not (No)",
    Variable == "Plant_uncertainty_type" ~ "If the name is unsure, type of species uncertainty is provided",
    Variable == "Pollinator_original_name" ~ "Pollinator species name given by the authors",
    Variable == "Pollinator_accepted_name" ~ "Harmonized pollinator species name in the database",
    Variable == "Pollinator_rank" ~ "Taxonomic rank of the observation",
    Variable == "Pollinator_order" ~ "Order taxonomic rank of the observed pollinator species",
    Variable == "Pollinator_family" ~ "Family taxonomic rank of the observed pollinator species",
    Variable == "Pollinator_genus" ~ "Genus taxonomic rank of the observed pollinator species",
    Variable == "Pollinator_unsure_id" ~ "Category to indicate if the pollinator species name is unsure (Yes) or not (No)",
    Variable == "Pollinator_uncertainty_type" ~ "If the name is unsure, type of species uncertainty is provided",
        Variable == "Flower_data" ~ "Floral data availability (Yes) or (No)",
        Variable == "Flower_data_merger" ~ "Column to merge floral data with the interaction dataset",

    TRUE ~ "Other"
  ))

#Check number of species and percentage of interactions of poll. groups
main_orders = c("Hymenoptera", "Diptera", "Lepidoptera", "Coleoptera")

order_info = data %>% 
select(Pollinator_order, Pollinator_accepted_name) %>% 
filter(Pollinator_order %in% main_orders) %>% 
group_by(Pollinator_order) %>% 
summarise(Interactions = length(Pollinator_accepted_name)/ nrow(.) *100,
          Species = n_distinct(Pollinator_accepted_name)) 

Hymenoptera_interactions = order_info %>% filter(Pollinator_order == "Hymenoptera") %>%
select(Interactions) %>% pull()

#Check percentage of studies with flower counts
floral_counts_percent = data  %>%
select(Study_id, Flower_data) %>% 
distinct() %>% 
group_by(Flower_data) %>% 
summarise(Percentage = n()/ nrow(.)*100) %>% 
filter(Flower_data == "Yes")

#Check percentage of apis mellifera records
all_records = data %>% nrow(.) 
apis_records = data %>% 
filter(Pollinator_accepted_name == "Apis mellifera") %>% 
nrow(.)
apis_percent = apis_records/all_records * 100
#Check average pecentage of interactions of apis by net
a = data %>% 
group_by(Network_id) %>% 
summarise(n_interactions = length(Pollinator_accepted_name))
b = data %>% 
group_by(Network_id) %>% 
filter(Pollinator_accepted_name == "Apis mellifera") %>% 
summarise(n_interactions_apis = length(Pollinator_accepted_name))
c = left_join(a,b)
apis_average_network = c %>% 
mutate(apis_percent_net = n_interactions_apis/ n_interactions *100) %>% 
ungroup() %>% 
summarise(mean_apis_percent_net = mean(apis_percent_net, na.rm=T)) %>% 
pull()

```


\vspace*{-14mm}


`r authors`

**Corresponding author**= barragansljose@gmail.com\
*All authors excluding the first four and last are ordered alphabetically*

\begingroup
\small

`r aff_list`

\small
\endgroup

\pagebreak

# Abstract
\vspace*{-5mm}

**Motivation:** Pollinators play a crucial role in maintaining Earth’s terrestrial biodiversity and human food production by mediating sexual reproduction for most flowering plants. Indeed, the network of interactions formed by plants and pollinators constitutes the backbone of plant-pollinator community stability and functioning. However, rapid human-induced environmental changes are compromising the long-term persistence of plant-pollinator interaction networks. One of the major challenges for pollinator conservation is the lack of robust generalisable data capturing how plant-pollinator communities are structured across space and time. Here, we present the EuPPollNet database, a fully open and reproducible European-level database containing harmonized taxonomic data on plant-pollinator interactions referenced in both space and time, along with other ecological variables of interest. This database offers an open workflow that allows researchers to track data-curation decisions and edit them according to their preferences. Furthermore, this work assesses the taxonomic and sampling coverage of the database at the European level, and the key structural properties in plant-pollinator networks. We hope this database will facilitate future research that fills taxonomic, ecological, and geographical data gaps on plant-pollinator interactions. Also, we believe it will help evaluate patterns and drivers of plant-pollinator network change and guide future conservation planning for both plant and pollinator species.

**Main Types of Variables Included:** EuPPollNet contains `r prettyNum(interaction_number, big.mark=",")` interactions between plants and pollinators from `r prettyNum(n_networks, big.mark=",")` distinct networks (i.e., distinct sampling event in space or time), which belong to `r study_number` different studies distributed across `r country_number` European countries. In addition, information about sampling methodology, habitat type, bio-climatic region, and further taxonomic rank information for both plant and pollinator species are also provided (i.e., family, order and phylum). 

**Spatial location and grain:** The database contains `r prettyNum(n_sites, big.mark=",")` different sampling locations from natural and anthropogenic habitats that fall in `r n_bioregion` different bio-climatic regions. All records are geo-referenced and presented in the World Geodetic System 1984 (WGS84).

**Time period and grain:** Species interaction data was collected between `r min_year` and `r max_year`. All records are time-referenced and most of the studies documented interactions within a single flowering season (`r format(round(one_year, 2), nsmall = 2)`%).

**Major taxa and level of measurement:** The database contains interaction data at the species level for `r format(round(species_level_int, 2), nsmall = 2)`% of the records, including a total of `r prettyNum(plant_spp_number, big.mark=",")` plant and `r prettyNum(pollinator_spp_number, big.mark=",")` pollinator species. The database covers `r format(round(plant_coverage, 2), nsmall = 2)`% of the European species of flowering plants, `r format(round(bee_coverage, 2), nsmall = 2)`% of bees, `r format(round(lepidoptera_coverage, 2), nsmall = 2)`% of butterflies, and `r format(round(syrphid_coverage, 2), nsmall = 2)`% of syrphid species at the European level.

**Software format:** The database was built with the R programming language and is stored as “.rds” and “.csv” formats. The construction of the database is fully reproducible and can be accessed at the following PERMANENT LINKS.


**KEYWORDS**\
\begingroup
\small
plant-pollinator networks, species interactions, flowering plants, Angiosperms, pollinators, nestedness, connectance
\endgroup
\pagebreak

# 1 | INTRODUCTION

Plant-pollinator interactions involve a great diversity of species, largely attributed to their coevolutionary history [@ollerton2017], and are critically important for terrestrial biodiversity and economic productivity. The synergistic effects of climate change with other global change pressures are threatening worldwide biodiversity [@sala2000; @bellard2014], including plant and pollinator species as well as their interactions [@goulson2015; @settele2016; @eichenberg2021]. Under this scenario, the increasing availability of biodiversity data plays a major role in our ecological understanding of species status, trends, and conservation [@heberling2021; @zattara2021]. However, our knowledge of plant and pollinator species and their network of interactions still exhibits major temporal, spatial and taxonomic biases [@archer2014; @troia2016; @poisot2021; @marshall2024], limiting our ability to effectively protect their biodiversity. 

The interactions between different plant and pollinator species within a community form complex networks. Macro-ecological analyses of the topology of these networks have revealed common properties across them, such as truncated power-law degree distributions [@jordano1987] or nestedness [@bascompte2003]. In addition, this type of large scale analyses can help understanding landscape level processes that cannot be explored at the community level, such as ecological patterns across geographic regions [@olesen2002; @traveset2016] or environmental gradients [@ramos2010; @rech2016; @saunders2023]. Although macro-ecological approaches make significant contributions to knowledge, they tend to be rare, and are strongly influenced by the spatio-temporal availability and nature of the data [@burkle2011; @trojelsgaard2013]. For instance, plant-pollinator studies tend to differ in sampling effort and methodology which affect the structure of the resulting plant-pollinator networks [@gibson2011; @jordano2016; @schwarz2020]. Most plant-pollinator networks have unobserved interactions [@olesen2011; @chacoff2012], and thus research that attempts to synthesize across published studies must have access to raw data on interactions in order to statistically account for sampling effort and completeness. Hence, this emphasizes the importance of evaluating the spatio-temporal coverage of interactions to guide future sampling efforts and accurately understand the processes that shape plant-pollinator interactions.


Europe is one of the continents with a larger amount of available biodiversity data [@proencca2017], yet still exhibits major gaps [@wetzel2018; @bennett2018]. While species checklists need to be treated carefully, especially at a macro-ecological scale [@grenie2023], the growing number of European plant and pollinator checklists [@reverte2023], along with occurrence data [@zattara2021], is setting a foundation for the conservation of its flora and their pollinators. However, species richness is just one component of biodiversity and documenting the interaction between plants and pollinators is essential for understanding biodiversity change [@jordano2016]. Numerous works have studied plant-pollinator interactions in the last decades, originating thousands of plant-pollinator interaction networks worldwide. Several initiatives have tried to integrate plant-pollinator interaction data into databases such as *Mangal* [@poisot2016] or *GloBI* [@poelen2014], resulting in numerous large scale comparative analyses that have enhanced our understanding of the ecology of plants and pollinators [e.g., European wild bee data trends\; @marshall2024]. Despite all these resources, Europe lacks accessible harmonized plant-pollinator interaction data that allow researchers to evaluate plant-pollinator interactions at a European level, which will guide research efforts, conservation planning and will set a foundation for future global change research. For example, only over a dozen of European plant-pollinator networks are included in *Mangal*, while *GloBI* focuses on pairwise interactions disconnected from the community context. Assembling and curating the existing information on EU plant-pollinator networks will guide research efforts, conservation planning and will set a foundation for future global change research.

Here, we present the European Plant-Pollinator Networks database (EuPPollNet), which contains harmonized information on interaction data of plants and pollinators at European level. The pollinator taxonomic groups are composed by the main orders of entomofauna that visit and pollinate flowering plants in Europe. These include insect species from the orders Hymenoptera, Diptera, Lepidoptera, and Coleoptera [@willemstein1987; @potts2015], which comprise almost the totality of recorded interactions in EuPPollNet (`r format(round(main_orders_percent, 2), nsmall = 2)`%). To understand the scope of the database, we examine the taxonomic and sampling coverage of the different plant and pollinator species at European level with the help of the most up-to-date species checklists and rarefaction analyses. In addition, we investigate how two key structural metrics of plant-pollinator networks, connectance and nestedness, change across the latitudes range of studies and bioclimatic regions. Given that this database contains one of the largest sets of plant-pollinator networks collated to date, and considering that the prevalence of nestedness has been evaluated only with a relatively small number of networks [@bascompte2003], we also examine whether plant-pollinator networks are more nested than expected by chance. EuPPollNet aims to cover a wide range of taxonomic groups and habitats, while also providing other variables of interest that define the ecological context and sampling methods of the study. In addition, EuPPollNet offers a transparent and accessible workflow of its data management and species harmonization that allows the database to be reused and to expand over time. This database provides a large number of community-level networks with curated and harmonized data, distinguishing it from other currently available resources that contain plant-pollinator interactions. We expect that EuPPollNet can be used to evaluate macro-ecological processes in plant-pollinator networks, guide conservation planning, and set a baseline for global change research.


# 2 | METHODS

## Data acquisition

The EuPPollNet database includes published and unpublished studies compiled initially by a wide number of researchers and institutions within the European continent. As this database is the result of one of the working packages of the European project Safeguard, first, data was directly asked to members of the Safeguard project. Second, the request was extended to data owners outside of the project. These other data owners were identified by direct communication with colleagues suggested by Safeguard members and by directly searching studies on Google Scholar of under-represented regions within the database. To keep high quality standards that will allow robust future ecological research, we only included studies meeting the following criteria: 1) studies that contained time- and geo-referenced records of plant-pollinator interactions; and 2) studies with phyto-centric plant-pollinator networks with quantitative visitation data.

## Dataset description

The database contains `r study_number` independent published and unpublished studies conducted during the time period `r min_year` - `r max_year` in `r country_number` different countries (**Figure 1a** and **Figure 1b**). The studies differ in sampling effort and methodology, and thus documenting sampling methods and sampling effort is an important feature of EuPPollNet. Most studies took place within a single flowering season (`r format(round(one_year, 2), nsmall = 2)`%), sampled a given location an average of `r format(round(average_sampling_days, 2), nsmall=2)` days, and documented interactions mostly by using `r  most_common_method[[1]]` as the sampling method (`r format(round(most_common_method[[3]], 2), nsmall = 2)`%). The database includes a total of `r prettyNum(interaction_number, big.mark=",")` distinct interactions, considering interaction as the contact of a pollinator individual to the reproductive structure of a particular plant. Most of the pollinator species in the database belong to the orders Hymenoptera and Diptera, each comprising approximately 1,000 species in the database. However, the majority of plant-pollinator interactions are from Hymenoptera species (`r format(round(Hymenoptera_interactions, 2), nsmall = 2)`%; **Figure 1c**). Notably,  _Apis mellifera_ represents `r format(round(apis_percent, 2), nsmall = 2)`% of the total interaction records from the database and an average of `r format(round(apis_average_network, 2), nsmall = 2)`% of the total interactions per network.


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="110%", fig.cap= "\\textbf{Figure 1}. (\\textbf{a}) Locations of the studies in EuPPollNet showing the total number of pollinator (i.e., orange heptagon) and plant (i.e., green circles) species per study. The sizes of these shapes are proportional to the respective species counts. For visualization purposes, we have focused only on the European region with studies and selected a single location per study. (\\textbf{b}) Number of studies by year in EuPPollNet. (\\textbf{c}) Number of species and interactions across the four main pollinator orders in EuPPollNet."}

#Fix dates
data = data %>%
dplyr::mutate(Year = lubridate::year(Date), 
                Month = lubridate::month(Date), 
                Day = lubridate::day(Date))

#Prepare coordinates
for_plotting = data %>% 
select(Study_id, Latitude, Longitude) %>% 
distinct()
#Get countries and transfrom coordinates
countries <- gisco_get_countries(
resolution = 20) %>%
st_transform(3035) %>% 
sf::st_as_sf(crs = 4326)

#Number of plant and poll species per network
#-----------------------#
#Pollinators------
#-----------------------#
#Check unique number of pollinator species
PollNumber_by_ID = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Study_id) %>% 
filter(Pollinator_rank == "SPECIES") %>% 
select(Pollinator_accepted_name, Study_id) %>% 
group_by(Study_id) %>% 
summarise(Pollinator_counts = n_distinct(Pollinator_accepted_name))
#Merge now with spp counts by network dataset
poll_data = left_join(PollNumber_by_ID, for_plotting, by = "Study_id")
#Create duplicate cord columns to operate on them
poll_data$coords <- data.frame(
Longitude = poll_data$Longitude, Latitude = poll_data$Latitude)
#Set coordinates
poll_data$coords_sf = st_as_sf(poll_data$coords, 
  coords = c("Longitude", "Latitude"), crs = 4326)
#Plot map of Europe
#Very noisy with many coordinates per point,
#Let's select a unique coordinate by study
poll_data1 =  poll_data %>% 
distinct(Study_id, .keep_all = TRUE)

#-----------------------#
#Plants-----
#-----------------------#
#Check unique number of plant species
PlantNumber_by_ID = data %>% 
select(Plant_rank, Plant_accepted_name, Study_id) %>% 
filter(Plant_rank == "SPECIES") %>% 
select(Plant_accepted_name, Study_id) %>% 
group_by(Study_id) %>% 
summarise(Plant_counts = n_distinct(Plant_accepted_name))
#Merge now with spp counts by network dataset
plant_data = left_join(PlantNumber_by_ID, for_plotting, by = "Study_id")
#Create duplicate cord columns to operate on them
plant_data$coords <- data.frame(
Longitude = plant_data$Longitude, Latitude = plant_data$Latitude)
#Set coordinates
plant_data$coords_sf = st_as_sf(plant_data$coords, 
  coords = c("Longitude", "Latitude"), crs = 4326)
#Plot map of Europe
#Very noisy with many coordinates per point,
#Let's select a unique coordinate by study
plant_data1 =  plant_data %>% 
distinct(Study_id, .keep_all = TRUE)

#Add vars
plant_data1$Group = "Plant"
poll_data1$Group = "Pollinator"
#Rename cols
plant_data2 = plant_data1 %>% 
rename(Counts = Plant_counts)
poll_data2 = poll_data1 %>% 
rename(Counts = Pollinator_counts)
#Bind rows
all_data = bind_rows(plant_data2, poll_data2)


#Try to plot both together (same plot)
map = ggplot(countries) +
geom_sf(fill="floralwhite",color = "black", 
        alpha = 1,linewidth=0.1) + 
geom_star(data = all_data, alpha=1,aes(x= Longitude, y=Latitude,
           size=Counts, starshape = Group, color= Group))+  
coord_sf(crs = st_crs(3035), default_crs = st_crs(4326),
         xlim = c(-14, 39), ylim = c(37, 70))+
theme(panel.grid.major = element_blank(), 
      legend.position = ("top"),
      legend.box = "vertical",
      legend.background = element_blank(),
      legend.box.background = element_blank(),
      legend.key = element_blank(), 
      legend.title = element_text(face ="bold",  size = 6),
      legend.box.spacing = unit(0.2, "cm"),
      legend.margin=margin(0,0,0,0),
        legend.box.margin=margin(-10,-10,-10,-10),
      axis.text = element_text(size=6,                  face="bold"),
      axis.title = element_text(face="bold", size = 8),
         legend.text = element_text(size = 6),                           legend.direction="horizontal",
         legend.spacing.y = unit(-0.3, "cm"),
      legend.title.align=0.5) +
theme(panel.background = element_rect(fill = "aliceblue"),
        panel.border = element_rect(colour = "black",
        fill=NA, size=1)) + 
 scale_size_continuous(name= "Species counts",range = c(0, 3.75))+
scale_color_manual(values=c("#009E73", "#D55E00"),
         guide="none") +
scale_starshape_manual(name = "Taxonomic group",             values = c(15, 7),
             guide=guide_legend(reverse=TRUE,
             override.aes=list(
                 size=2,
                 color=c("Pollinator"= "#D55E00","Plant"="#009E73")))) +
  ylab("Latitude") +
xlab("Longitude") +
scale_x_continuous(breaks = seq(0, 20, by = 10)) +
scale_y_continuous(breaks = seq(40, 60, by = 10)) +
guides(color = "none", size=guide_legend(nrow=1,override.aes = list(starshape =c(15,15, 15), size=c(0.8,1.8,2.8)))) + 
ggtitle("(a)") +
theme(plot.title = element_text(vjust = -5, hjust=0.057, size=10))


#----------------#
#Pollinators
#----------------#
#First select cols of rank, accepted name and study ID
#Then select unique levels by study ID
#Now sum levels (maximum can be as maximum number of studies)
poll_spread = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Study_id) %>% 
group_by(Study_id) %>% 
filter(Pollinator_rank == "SPECIES") %>% 
distinct(Pollinator_accepted_name) %>% 
ungroup() %>% 
count(Pollinator_accepted_name) %>% 
rename(n_studies_shared = n) %>% 
arrange(-n_studies_shared) %>% 
mutate(Percent_total = n_studies_shared / n_distinct(data$Study_id))
  
#Seelect quantile 50% from the total number of species
spp_number = poll_spread %>%  
select(Pollinator_accepted_name) %>% 
n_distinct()
df = seq(1, spp_number)
quantile_50 = quantile(df, 0.5)

#Obtain most common pollinator for plotting
most_common_poll = poll_spread %>% filter(n_studies_shared == max(n_studies_shared)) %>%
select(Pollinator_accepted_name) %>% pull() 

#Plot
#p1 = ggplot(poll_spread, 
#aes(reorder(Pollinator_accepted_name,-Percent_total), Percent_total)) +
#geom_bar(stat = "identity", 
#           color = "#D55E00",
#           lwd = 0.015, fill = "#D55E00") +
#ylab("Shared pollinators (%)") +
#theme_minimal()+
#theme(axis.text.x = element_blank(),
#  axis.ticks.x=element_blank(),
#  axis.ticks.y = element_line(size = 0.2),
#  plot.title = element_text(size = 8, face = "bold"), 
#  axis.text.y = element_text(size=5),
#  panel.grid.major.x = element_blank(),
#  panel.grid.minor.y = element_blank(),
#  panel.grid.major.y = element_line(size=0.2, linetype =           2)) +
#xlab(NULL) +
#ylab(NULL) + 
#ggtitle("Pollinators")+
#geom_vline(xintercept = quantile_50, linetype="dashed", 
#color = "black", size=0.25) + 
#annotate(geom="text", x=1285, y=0.83, label="50th percentile",          color="black", size = #1.5) +
#annotate(geom="text", x=20, y=0.88, label=most_common_poll[1],         color="black",  #fontface = 'italic', size = 1.5)+
#scale_y_continuous(breaks = seq(0, 0.75, by= 0.25), expand = c(0, 0)) + 
#annotate(geom="text", x=-500, y=1.15, label="(c)",color="black", size = 3.5) +
#coord_cartesian(xlim=c(0, nlevels(factor(poll_spread$Pollinator_accepted_name))),ylim=c(0, #max(poll_spread$Percent_total)), clip="off")
#
##----------------#
##Plants
##----------------#
#plant_spread = data %>% 
#select(Plant_rank, Plant_accepted_name, Study_id) %>% 
#group_by(Study_id) %>% 
#filter(Plant_rank == "SPECIES") %>% 
#distinct(Plant_accepted_name) %>% 
#ungroup() %>% 
#count(Plant_accepted_name) %>% 
#rename(n_studies_shared = n) %>% 
#arrange(-n_studies_shared) %>% 
#mutate(Percent_total = n_studies_shared / n_distinct(data$Study_id))
#  
##Seelect quantile 50% from the total number of species
#spp_number = plant_spread %>%  
#select(Plant_accepted_name) %>% 
#n_distinct()
#df = seq(1, spp_number)
#quantile_50 = quantile(df, 0.5)
#
##Obtain most common plant for plotting
#most_common_plant = plant_spread %>% filter(n_studies_shared == max(n_studies_shared)) %>%
#select(Plant_accepted_name) %>% pull() 
#
#Plot
#p2 = ggplot(plant_spread, 
#aes(reorder(Plant_accepted_name,-Percent_total), Percent_total, fill = Plant_accepted_name)) +
#geom_bar(stat = "identity", 
#           color = "#009E73",
#           lwd = 0.015, fill = "#009E73") +
#theme_minimal()+
#theme(axis.text.x = element_blank(),
#         axis.ticks.x=element_blank(),
#         axis.ticks.y = element_line(size = 0.2),
#         axis.title.x = element_text(face = "bold", size = 7),            plot.title = #element_text(size = 8, face = "bold"),
#         axis.text.y = element_text(size=5),
#         panel.grid.major.x = element_blank(),
#         panel.grid.minor.y = element_blank(),
#         panel.grid.major.y = element_line(size=0.2, linetype =  2),
#      axis.title.y = element_text(face= "bold", size= 7, hjust= -0.01, vjust = 1)) +
#xlab("Species") +
#ylab("Occurrence across studies") + 
#ggtitle("Plants") + 
#geom_vline(xintercept = quantile_50, linetype="dashed", 
#          color = "black", size=0.25) + 
#annotate(geom="text", x=835, y=0.7, label="50th percentile",color="black", size = 1.5) + 
#annotate(geom="text", x=20, y=0.75, label=most_common_plant[1]
#      ,color="black",  fontface = 'italic', size = 1.5)+
#annotate(geom="text", x=20, y=-0.08, label="Common spp."
#      ,color="black",  size = 1.5) +
#annotate(geom="text", x=1200, y=-0.08, label="\'Rare\' spp."
#      ,color="black",  size = 1.5) + 
#scale_y_continuous(breaks = seq(0, 0.6, by= 0.2), expand = c(0, 0), labels = #label_number(accuracy = 0.01)) +
#coord_cartesian(xlim=c(0, nlevels(factor(plant_spread$Plant_accepted_name))),ylim=c(0, #max(plant_spread$Percent_total)), clip="off")
#


data2 = data %>%  select(Study_id, Year) %>% 
distinct() %>% 
group_by(Year) %>% 
summarise(Counts = n())

p2  = ggplot(data2, aes(Year, Counts)) +
geom_col(fill = "gray25", width = 0.9, color="black", linewidth = 0.4) +
theme_light() +
theme(plot.margin=unit(c(0,0,0,0), "mm"),
  axis.title.y = element_text(face = "bold", size = 7, vjust = -2),
  axis.title.x = element_text(face = "bold", size = 8),
  axis.text.y = element_text(size = 6),
  axis.text.x = element_text(size = 6,  angle = 90), 
  strip.text.x = element_text(size=12),
   axis.ticks.x = element_line(color="black"),
  strip.background = element_rect(
  color="black", fill=NA, size=0.5, linetype="solid")) + 
ylab("Number of studies") +
coord_cartesian(expand = F, clip = "off") + 
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
  panel.background = element_blank(),
  panel.border = element_rect(colour = "black", fill=NA, size=1)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black')) +
scale_y_continuous(breaks = c(0, 4,8,12), labels = c("0", "4","8", "12"), limits = c(0,12)) +
scale_x_continuous(breaks = seq(min(data2$Year), max(data2$Year), by = 2), limits = c(min(data2$Year),max(data2$Year)))+
ggtitle("(b)") +
theme(plot.title = element_text(size = 10,hjust = -0.3, vjust = -5))




main_orders = c("Hymenoptera", "Diptera", "Lepidoptera", "Coleoptera")
#Select main orders
data1 = data %>% 
select(Pollinator_order, Pollinator_accepted_name) %>% 
filter(Pollinator_order %in% main_orders) %>% 
group_by(Pollinator_order) %>% 
summarise(Species = n_distinct(Pollinator_accepted_name)/n_distinct(.),
          Interactions = length(Pollinator_accepted_name)/ nrow(.))


# Combine Interactions and Species into a single column
data_long = pivot_longer(data1, cols = c(Interactions, Species), names_to = "Variable", values_to = "Value")

#Set order of levels for plotting
data_long$Pollinator_order = factor(data_long$Pollinator_order, levels = c("Coleoptera", "Lepidoptera", "Diptera", "Hymenoptera"))

#Plot
p3 = ggplot(data_long, aes(x = Variable, y = Value, fill = Pollinator_order)) + 
geom_bar(stat = "identity", width = 0.7) +
theme_classic() +
scale_fill_viridis(discrete=TRUE, direction = -1, name="Pollinator order") +
xlab(NULL) +
ylab("Percentage") + 
scale_y_continuous(labels = percent_format(), expand = c(0, 0)) +
theme(axis.text = element_text(size=6), 
     axis.title.y = element_text(face = "bold", size = 7, vjust = -2),  
     axis.title.x = element_text(face="bold", size = 7),
     legend.position = "top",
     legend.title = element_text(size = 5, face = "bold"),
     legend.text = element_text(size = 5),
     legend.key.size = unit(3, "mm"),
     legend.margin=margin(0,0,0,0),
     legend.box.margin=margin(-8,-5,-5,-5)) +
guides(fill=guide_legend(nrow=2,byrow=TRUE))+
ggtitle("(c)") +
theme(plot.title = element_text(size = 10,hjust = -0.3, vjust = -6))


#plot2 = p3 / p1 / p2 
plot2 = p2 / p3 

#Plot everything
map + plot_spacer() + plot2 + plot_layout(widths = c(2.1, -0.485, 0.8)) 


```

\newpage

## Data structure

The EuPPollNet database is available in both .csv and .rds formats. The .csv file contains data in long format, while the .rds file stores the data in a list structure, with networks organized within each study. The file contains a total of `r nrow(my_tibble) + 1` columns that depict where and when the plant-pollinator interaction was observed (**Table 1**). To provide a standard unit of plant-pollinator interaction across studies, each row depicts a single interaction between a plant and a pollinator species. To build a plant-pollinator network matrix within a single flowering season at a site level, users only need to group interactions by plant and pollinator species, site, study and year. Information about habitat type and bioclimatic region are also provided in this file. In addition, the interaction dataset includes a column that describes the presence or absence of floral counts for each study. The flower count data is provided in a separate file. Two thirds of studies contain information on floral abundance, but the methods and units differ greatly across studies. Finally, metadata at the study level is provided, including information about the authors, digital object identifier if available, sampling time and taxonomic coverage of the main pollinator groups for each study.


```{r, echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, fig.height=1, fig.width=10}


kable(my_tibble, booktabs = T, linesep = "\\addlinespace", caption = "\\textbf{Table 1.} Column names and their descriptions within the EuPPollNet database.") %>%
  kable_styling(full_width = F,font_size = 9) %>% row_spec(0, bold=T) %>% 
kable_styling(position = "center")


```


## Taxonomic harmonization

All plant and pollinator species names were checked and harmonized in R using **rgbif** [@chamberlain2022]. The protocol for plants and pollinators is similar but slightly different given the availability of the different taxonomic resources. For transparency, we have included in the database the original species name, the new assigned name, and, if the name of the species is uncertain (e.g., species complex or species alike). In addition, taxonomic information at family, order and phylum level was downloaded for each species.

For plants: (i) we initially verified the exact matches against the GBIF species checklist; (ii) we selected unmatched cases and fixed orthographic errors; (iii) we retrieved again taxonomic information for those unmatched cases, evaluated accuracy of fuzzing matching and programmatically fixed records that are still not found; (iv) finally, we used the World Flora Taxonomic Backbone [@govaerts2021\; WFO, July 7, 2022] as the ultimate filter for taxonomic information as we used it to calculate the plant taxonomic coverage of our database.

For pollinators: (i) we first created a checklist of species names for the most representative pollinator groups at the European level by combining the most up to date published checklists of bees and syrphids [@reverte2023] with the one of butterflies [@wiemers2018]; (ii) we compared pollinator species names against the checklist and recovered some unmatched cases with restrictive fuzzy matching by using **stringdist** package [@van2014]; (iii) we fixed unmatched records when necessary and retrieved the taxonomic information for all species from GBIF; (iv) we fixed the non-found cases in the GBIF checklist and made sure that all species names from bees, syrphids and butterflies were named according to their respective species checklists. Coleoptera species names were only checked against the GBIF checklist.

## Taxonomic coverage 

To assess the completeness of plant and pollinator species in the EuPPollNet database at European level, we used the aforementioned checklists for plants and pollinators. Specifically for plants, we refined the checklist to include only European flowering plants and excluded taxonomic groups not associated with biotic pollination. We did this by first excluding the families considered to have exclusively a wind pollination mode [see @culley2002], and then by filtering out the genera with wind or non-biotic pollination from families that exhibit both biotic and non-biotic pollination modes. Additionally, we manually included some exotic species and added unresolved species names that were not present in the accepted names of the checklist at the current version of usage. For pollinators, we compared only the taxonomic coverage of bees, syrphids and butterflies by using their species checklists at European level. The potential number of pollinator species at European level was estimated by adding the total number of species of bees, syrphids, and flies from the checklists, along with the extrapolated number of species from other insect pollinators. This extrapolated number was estimated by assuming that the sampling coverage of these other insect pollinators is equal to the average coverage across bees, syrphids, and butterflies (mean coverage = `r round(mean_coverage, 2)`; sd = `r round(sd_coverage,2)`).

Finally, to evaluate if the presence-absence of interaction records for bees and flowering plants follows a phylogenetic pattern within the database, we calculated its phylogenetic signal  at genus and family level, respectively. The phylogenetic signal was calculated by using the _phylosig_ function from the **phytools** package [@revell2012]. We extracted the phylogenetic information for bees from a genus level phylogeny [@hedtke2013] and processed it using the packages **ape** [@paradis2019], **MCMCglmm** [@hadfield2010] and **phytools**. For plants, the phylogenetic tree was obtained from a species level plant phylogeny [@smith2018] with the help of the **rtree** package [@li2023].

## Sampling coverage 

The completeness of the EuPPollNet database was evaluated by exploring the rarefied accumulation curves of plant and pollinator species and their interactions across the different sampling sites. In addition, an outstanding question in ecology is how many pollinators are required to pollinate flowering plants [e.g., @kleijn2015 for crops]. To that end, we also calculated the accumulation curve of pollinator species with an increasing number of plant species. The rarefied and extrapolated sampling curves were obtained using the **iNEXT** package [@hsieh2016]. This was complemented with 100 random accumulation curves obtained programmatically to guide the visualization of the different rarefied curves.

## Habitat type and bioclimatic region

The different sites were described with a habitat type by the authors of each study. We standardized  the habitat type using the author's description and land cover information from Corine Land Cover (CLC, version 2018) extracted using the Terra package [@hijmans2022]. Based on the habitat classification from the authors and the CLC classification, we created habitat categories that intend to summarize the diversity of habitats in the EuPPollNet database (see habitat type definition in supplementary material). These categories allow a quick comparison and understanding of the habitat types from the database. Moreover, Europe is characterized by a great variety of environmental conditions that harbor different biota. Thus, to allow authors to explore the set of studies that share similar environmental conditions and species, we assigned to each site a biogeographical region. The biogeographical regions were downloaded from the European Environment Agency (version 2016) and were matched to the different sites using a spatial joint from the **sf** package [@pebesma2018].


## Network analyses

To provide a general overview of the structure of plant-pollinator networks in EuPPollNet, we quantified connectance and nestedness and examined how these network metrics change across the latitudinal range of studies and bioclimatic regions. We selected these two network metrics as they are commonly evaluated in plant-pollinator network studies and capture structural properties with a straightforward interpretation. However, these network metrics are not independent of sampling effort (e.g., number of species) and to allow comparisons across them, we implemented “standardised” versions of connectance and nestedness. As connectance is negatively associated with network size [@jordano1987], we evaluated how network connectance was associated with the number of species  (i.e., log of geometric mean of plants and pollinators) and extracted the residuals from this association (i.e., residual connectance) as a measurement of corrected connectance. This was done with the help of a Beta regression implemented with the package **betareg** [@cribari2010]. Second, we implemented a metric of nedstedness (i.e., NODFc) that allows the comparison across networks as it corrects by connectance and the number of species [@song2017]. This metric was calculated with the help of the **maxnodf** package [@hoeppke2021], which employs a computational eﬀicient approach to calculate it. Both residual connectance and NODFc were used as dependent variables to evaluate their association with latitude. In addition, we explored the association between connectance and nestedness with the number of species per network by conducting Kendall rank correlation coefficient in order to be able to compare the strength of this association across both network metrics. 

Finally, to compare if networks are more or less nested than expected by chance, we employed the traditional z-score approach with the widely used nestedness metric (NODF) from @almeida2008, as this approach allow us to compare our results with previous published nestedness analysis in plant-pollinator networks and only compares each unique network against their randomized versions. We calculated 100 null models for each network with the help of the _vaznull_ function from the package **bipartite** [@dormann2008] that implements the null model from @vazquez2005. These null networks have the same connectance and number of plant and pollinator species as the empirical ones, but different marginal totals. Both connectance and nestedness (NODF) were estimated for each network by using the function _networklevel_ from **bipartite**.

\newpage 

# 3 | RESULTS



```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE}
#Taxonomic coverage outputs
#Find number of plant and pollinator species
##Pollinators
poll_spp = data %>% 
select(Pollinator_rank, Pollinator_accepted_name) %>% 
filter(Pollinator_rank == "SPECIES") %>% 
distinct(Pollinator_accepted_name) %>% 
nrow(.)
##Plants
plant_spp = data %>% 
select(Plant_rank, Plant_accepted_name) %>% 
filter(Plant_rank == "SPECIES") %>% 
distinct(Plant_accepted_name) %>% 
nrow(.)

#Overall plant coverage
plant_coverage = readRDS("../Data/Manuscript_info/plant_coverage.RData")

#Average plant family coverage
d1 = readRDS("../Data/Manuscript_info/plant_coverage_phylo_RData") %>% 
filter(fam_group == "B")
#Average coverage per family
mean_plant_fam_cov = d1 %>% 
ungroup() %>% 
summarise(mean_plant_fam_cov = mean(Percent)) %>% 
pull()

#Percent of families with interaction records
all_fam = nrow(d1)
fam_with_data = d1 %>% 
filter(Percent > 0) %>% 
nrow()
percent_plant_fam_with_data = fam_with_data/all_fam * 100

#Calculate phylogenetic signal of presence-absence information
#Read data and plot it
tree = readRDS("../Data/Manuscript_info/plant_phylo.RData")
#Create binary trait to calculate phylo
phylo_trait = d1 %>% 
mutate(categorical = case_when(Percent > 0 ~ 1, TRUE ~ 0)) %>% 
#select(label, categorical) %>% 
ungroup() 
#Check phylogenetic signal
d1 = d1 %>% arrange(factor(label, levels = tree@phylo$tip.label))

v = phylo_trait$categorical
names(v) = tree@phylo$tip.label

phylo_signal_plant = phylosig(tree@phylo, v, method="lambda", test=TRUE)
lambda_phylosig_plants = phylo_signal_plant$lambda
p_phylosig_plants = phylo_signal_plant$P

#Load pollinator coverage
bee_coverage = readRDS("../Data/Manuscript_info/bee_coverage.RData")
syrphid_coverage = readRDS("../Data/Manuscript_info/syrphid_coverage.RData")
lepidoptera_coverage = readRDS("../Data/Manuscript_info/lepidoptera_coverage.RData")
#Check percentage of interactions from bees with and without apis
#Check percentage of bees in the database
bee_fam = c("Apidae", "Megachilidae", "Halictidae",
            "Andrenidae", "Colletidae", "Melittidae")
all_rows = data %>% nrow(.)
#
bee_rows = data %>%
filter(Pollinator_family %in% bee_fam) %>% 
nrow(.)
#Bee interactions
bee_interactions_percent = bee_rows/all_rows *100
#Eclude now apis
bee_rows_non_apis = data %>%
filter(Pollinator_family %in% bee_fam) %>% 
filter(Pollinator_accepted_name == "Apis mellifera") %>% 
nrow(.)
#
bee_interactions_non_apis_percent = bee_rows_non_apis/bee_rows *100

#Coverage across bee genera
d1 = readRDS("../Data/Manuscript_info/bee_data.RData")
all_rows_bees = d1 %>%  
filter(fam_group == "a") %>% 
nrow(.)
#
data_bees = d1 %>%  
filter(fam_group == "a") %>% 
mutate(Percent = case_when(is.na(Percent) ~ 0, TRUE ~ Percent)) %>% 
filter(Percent > 0) %>% 
nrow(.)
#
bee_genera_percent_coverage = data_bees/all_rows_bees * 100
#Check average coverage across bee genera
average_coverage_bee_genera = d1 %>% 
filter(fam_group == "a") %>% 
mutate(Percent = case_when(is.na(Percent) ~ 0, TRUE ~ Percent)) %>% 
ungroup() %>% 
summarise(average_coverage_bee_genera = mean(Percent)) %>% 
pull()

#Calculate phylogenetic signal of presence-absence information
##Read data and plot it
tree = readRDS("../Data/Manuscript_info/bee.tree100.rds")
##Create binary trait to calculate phylo
phylo_trait = d1 %>% 
filter(fam_group == "a") %>% 
mutate(Percent = case_when(is.na(Percent) ~ 0, TRUE ~ Percent)) %>% 
mutate(categorical = case_when(Percent > 0 ~ 1, TRUE ~ 0)) %>% 
ungroup() 
##Conduct left join to tibble of tip labels to organise order
v = tibble(Genus1 = tree$tip.label) %>% 
mutate(Genus1 = str_to_title(word(Genus1,1,sep = "_")))
#
v1 = left_join(v, phylo_trait)
#
v2 = v1$categorical
names(v2) = tree$tip.label
#
phylo_signal_bees = phylosig(tree, v2, method="lambda", test=TRUE)
lambda_phylosig_bees = phylo_signal_bees$lambda
p_phylosig_bees = phylo_signal_bees$P

#Check number of studies by habitat
studies_by_habitat = data %>% 
select(Study_id, EuPPollNet_habitat) %>% 
distinct() %>%  
group_by(EuPPollNet_habitat) %>% 
summarise(Habitat_count = n()) %>% 
slice_max(Habitat_count, n = 3) %>% 
mutate(EuPPollNet_habitat = tolower(EuPPollNet_habitat))
#Check number of sampling sites by habitat
networks_by_habitat = data %>% 
select(Network_id, EuPPollNet_habitat) %>% 
distinct() %>%  
group_by(EuPPollNet_habitat) %>% 
summarise(Habitat_count = n()) %>% 
slice_max(Habitat_count, n = 3) %>% 
mutate(EuPPollNet_habitat = tolower(EuPPollNet_habitat))
#Check number of studies by bioregion
studies_by_bioregion = data %>% 
select(Study_id, Bioregion) %>% 
distinct() %>%  
group_by(Bioregion) %>% 
summarise(Bioregion_count = n()) %>% 
slice_max(Bioregion_count, n = 3) %>% 
mutate(Bioregion = tolower(Bioregion))
#Check number of sampling sites by bioregion
networks_by_bioregion = data %>% 
select(Network_id, Bioregion) %>% 
distinct() %>%  
group_by(Bioregion) %>% 
summarise(Bioregion_count = n()) %>% 
slice_max(Bioregion_count, n = 3) %>% 
mutate(Bioregion = tolower(Bioregion))
#Check percentage of Apis mellifera across networks
apis_percent_networks = data %>% 
filter(Pollinator_accepted_name == "Apis mellifera") %>%
group_by(Study_id) %>% 
mutate(Apis = "Yes") %>% 
distinct(Study_id, Apis) %>% 
nrow() / nlevels(factor(data$Study_id)) *100

```

## Taxonomic coverage

EuPPollNet contains a total of `r prettyNum(pollinator_spp_number, big.mark=",")` pollinators and `r prettyNum(plant_spp_number, big.mark=",")` plant species. The coverage of the main pollinators groups occurring in Europe is `r format(round(bee_coverage, 2), nsmall=2)`% for bees, `r format(round(syrphid_coverage, 2), nsmall=2)`% for syrphids and `r format(round(lepidoptera_coverage, 2), nsmall=2)`% for butterflies (see **Figure S1** for coverage at the family level for bees and butterflies, and at the subfamily level for syrphids). Bees constitute `r format(round(bee_interactions_percent, 2), nsmall=2)`% of the interactions in EuPPollNet, and `r format(round(bee_interactions_non_apis_percent, 2), nsmall=2)`% of the interactions when excluding honey bees. Within the database, `r format(round(bee_genera_percent_coverage, 2), nsmall=2)`% of bee genera have at least one species with interaction records, and the average coverage of species at the bee genus level is `r format(round(average_coverage_bee_genera, 2), nsmall=2)`% (**Figure 2**). In addition, the presence or absence of interaction records for bees does not follow a phylogenetic pattern ($\lambda$ = `r format(round(lambda_phylosig_bees, 2), nsmall=2)`; _P_ = `r format(round(p_phylosig_bees, 2), nsmall=2)`). The database coverage of all flowering plant species occurring in Europe is `r format(round(plant_coverage, 2), nsmall=2)`% (**Figure 3**), with an average coverage of `r format(round(mean_plant_fam_cov, 2), nsmall=2)`% at the plant family level. Approximately, half of the plant families have at least one species with interaction records (`r format(round(percent_plant_fam_with_data, 2), nsmall=2)`%), and the presence or absence of interaction data for the different plant species also seems not to follow a statistically relevant phylogenetic pattern ($\lambda$ = `r format(round(lambda_phylosig_plants, 2), nsmall=2)`; _P_ = `r format(round(p_phylosig_plants, 2), nsmall=2)`). 


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="95%", fig.width=10, fig.height=10, fig.cap= "\\textbf{Figure 2}. Phylogenetic and taxonomic coverage of the bee genera at European level. The number of interactions recorded per genus in the database is illustrated using circles, with their sizes proportional to the number of interactions on a logarithmic scale. Additionally, a gradient of colors ranging from yellow to dark purple aids in this visualization. The coverage of species recorded in EuPPollNet per genus at the European level is depicted with orange and light grey bars, representing the percentage of species included and not included in the database, respectively, out of the total number of bee species per genus at the European level. Grey bars indicate the total number of species per genus at the European level."}

#Read data
tree_family_interactions= readRDS("../Data/Manuscript_info/bee_phylo.RData")
d1 = readRDS("../Data/Manuscript_info/bee_data.RData")
n = readRDS("../Data/Manuscript_info/node_data.RData")

#Circular layour
ggtree(tree_family_interactions, size=0.6, open.angle=1, alpha=1)+ 
geom_tippoint(aes(size= Interactions, fill = Interactions), color="black", shape=21) +
geom_tiplab(linetype='dashed', linesize=.05, offset = 0.063, size=2.9, fontface=1) +
scale_size(range = c(0,4.5), guide = 'none')  +
scale_fill_continuous(type = "viridis", direction=-1) + 
guides(fill=guide_legend(), size = guide_legend()) +
theme(legend.position = "bottom") +
new_scale_fill() +
geom_fruit(data = d1, geom=geom_bar,
                    mapping=aes(y=Genus1, x=Percent, fill = fam_group),
                    pwidth=0.13, 
                    orientation="y", 
                    stat="identity",
                    color="black",
                    offset = 0.137,
            axis.params=list(
                         axis = "x",
                         text.size  = 2.5,
                         hjust  = 1,
                         vjust = 0.5,
                         nbreak = 3,
                         fontface = 2
                     ),
         grid.params=list()) +
guides(fill = "none")+
scale_fill_manual(values = c(a = "tan2", b = "lightgrey"), guide = "none")+
geom_fruit(geom=geom_bar,
                    mapping=aes(y=label, x=Spp_number_Europe),
                    pwidth=0.12, 
                    orientation="y", 
                    stat="identity",
                    color="black",
                    offset = 0,
            axis.params=list(
                         axis = "x",
                         text.size  = 2.5,
                         hjust  = 1,
                         vjust = 0.5,
                         nbreak = 1,
                         fontface = 2
                     ),
         grid.params=list()) +
annotate("text", x = 14.2, y = 70, label = "EuPPollNet spp\n coverage (%)", size= 3, fontface= "bold") +
annotate("text", x = 15.7, y = 70, label = "European\n species", size= 3, fontface= "bold")+
annotate("text", x = 12.1, y = 70, label = "EuPPollNet\n interactions", size= 3, fontface= "bold")+ 
new_scale_fill() +
geom_hilight(data=n, aes(node=node), type = "roundrect", fill = "orange") +
annotate("text", x = 7.5, y = 2.8, label = "Melittidae", size= 3)+
annotate("text", x = 7, y = 6.5, label = "Andrenidae", size= 3)+
annotate("text", x = 9.5, y = 12.5, label = "Colletidae", size= 3)+
annotate("text", x = 5.9, y = 17.4, label = "Halictidae", size= 3)+
annotate("text", x = 2.8, y = 28.6, label = "Apidae", size= 3)+
annotate("text", x = 2.8, y = 51.3, label = "Megachilidae", size= 3) +
coord_cartesian(clip = "off")+
theme(legend.margin=unit(1,"cm"),
      legend.spacing = unit(1, "cm"),
      plot.margin = margin(4,0,4,0), 
      legend.position = c(0.6,0),
      legend.direction = "horizontal") 


```


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="95%", fig.cap= "\\textbf{Figure 3}. Phylogenetic and taxonomic coverage of the plant families at European level. The number of interactions recorded per genus in the database is illustrated using circles, with their sizes proportional to the number of interactions on a logarithmic scale. Additionally, a gradient of colors ranging from yellow to dark purple aids in this visualization. The coverage of species recorded in EuPPollNet per genus at the European level is depicted with orange and light grey bars, representing the percentage of species included and not included in the database, respectively, out of the total number of flowering plant species per family at the European level. Grey bars indicate the total number of species per family at the European level on logarithmic scale.", fig.width=8, fig.height=8}

library(ggplot2)
library(ggtree)
library(ggnewscale)
library(ggtreeExtra)
library(cowplot)


#Save data and plot it in an Rmarkdown
tree_family_interactions = readRDS("../Data/Manuscript_info/plant_phylo.RData")
d1 = readRDS("../Data/Manuscript_info/plant_coverage_phylo_RData")

#Check if there are differences in labels and order
ggtree(tree_family_interactions, layout="circular", size=0.15, open.angle=5, alpha=0.25) +
geom_tippoint(aes(size= Interactions, fill = Interactions), color="black", shape=21) +
geom_tiplab(linetype='dashed', linesize=.05, offset = -5, size=1.85, fontface=2, hjust=1) +
scale_size(range = c(0,4), guide = 'none') +
scale_fill_continuous(type = "viridis", direction=-1) + 
theme(legend.position = "bottom") +
guides(fill=guide_legend(), size = guide_legend()) +
new_scale_fill() +
geom_fruit(data = d1, geom=geom_bar,
   mapping=aes(y=label, x=Percent, fill = fam_group),
   pwidth=0.1, 
   orientation="y", 
   stat="identity",
   color="black",
   offset = 0.028,
   linewidth=0.35,
   axis.params=list(
     axis = "x",
     text.size  = 1.5,
     hjust  = 1,
     vjust = 0.5,
     nbreak = 3,
     fontface = 2),
  grid.params=list())+
guides(fill = "none")+
scale_fill_manual(values = c(A = "lightgrey", B = "tan2"), guide = "none") +
geom_fruit(geom=geom_bar,
    mapping=aes(y=label, x=log(Spp_Europe +1)),
    pwidth=0.1, 
    orientation="y", 
    stat="identity",
    color="black",
    offset = 0,
    linewidth=0.35) +
theme(legend.margin=unit(1,"cm"),
      legend.spacing = unit(1, "cm"),
      plot.margin = margin(4,0,4,0), 
      legend.position = c(0.5,0.09),
      legend.direction = "horizontal") 

```


\newpage


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE}

#Sampling coverage outputs
poll_output = readRDS("../Data/Working_files/pollinator_sampling_coverage.rds")
plant_output = readRDS("../Data/Working_files/plant_sampling_coverage.rds")
int_output = readRDS("../Data/Working_files/interactions_sampling_coverage.rds")
plant_poll_output = readRDS("../Data/Working_files/plant_poll_spp_sampling_coverage.rds")

#Coverage
poll_coverage = poll_output$DataInfo$SC *100
plant_coverage = plant_output$DataInfo$SC *100
int_coverage = int_output$DataInfo$SC *100
plant_poll_coverage = plant_poll_output$DataInfo$SC *100

#Increase doubling effort
##Pollinators
poll_increase = poll_output$iNextEst$Network_id
poll_increase1 = poll_increase %>% filter(method == "observed") %>% pull(qD)
poll_increase2 = poll_increase %>% filter(t == max(t)) %>% pull(qD)
poll_increase3 = (poll_increase2-poll_increase1)/poll_increase1 * 100
##Plants
plant_increase = plant_output$iNextEst$Network_id
plant_increase1 = plant_increase %>% filter(method == "observed") %>% pull(qD)
plant_increase2 = plant_increase %>% filter(t == max(t)) %>% pull(qD)
plant_increase3 = (plant_increase2-plant_increase1)/plant_increase1 * 100
##Interactions
int_increase = int_output$iNextEst$Network_id
int_increase1 = int_increase %>% filter(method == "observed") %>% pull(qD)
int_increase2 = int_increase %>% filter(t == max(t)) %>% pull(qD)
int_increase3 = (int_increase2-int_increase1)/int_increase1 * 100
##Pollinator by plant
plant_poll_increase = plant_poll_output$iNextEst$Plant_id
plant_poll_increase1 = plant_poll_increase %>% filter(method == "observed") %>% pull(qD)
plant_poll_increase2 = plant_poll_increase %>% filter(t == max(t)) %>% pull(qD)
plant_poll_increase3 = (plant_poll_increase2-plant_poll_increase1)/plant_poll_increase1 * 100

#Prepare results from common and rare poll across sampling sites
#Pollinators
poll_spread = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Network_id) %>% 
group_by(Network_id) %>% 
filter(Pollinator_rank == "SPECIES") %>% 
distinct(Pollinator_accepted_name) %>% 
ungroup() %>% 
count(Pollinator_accepted_name) %>% 
rename(n_networks_shared = n) %>% 
arrange(-n_networks_shared) %>% 
mutate(Percent_total = n_networks_shared / n_distinct(data$Network_id)*100)
#Check number of studies under 1%
poll_total = nrow(poll_spread)
polls_under_one_percent = poll_spread %>% 
filter(Percent_total<1) %>% 
nrow()
polls_under_one_percent = polls_under_one_percent/poll_total * 100
#Find most common pollinator
most_common_poll = poll_spread %>% 
filter(Percent_total == max(Percent_total)) %>% 
pull(Pollinator_accepted_name)
#Find most common poll percent
most_common_poll_percent = poll_spread %>% 
filter(Percent_total == max(Percent_total)) %>% 
pull(Percent_total)
#Plants
plant_spread = data %>% 
select(Plant_rank, Network_id, Plant_accepted_name) %>% 
group_by(Network_id) %>% 
filter(Plant_rank == "SPECIES") %>% 
distinct(Plant_accepted_name) %>% 
ungroup() %>% 
count(Plant_accepted_name) %>% 
rename(n_networks_shared = n) %>% 
arrange(-n_networks_shared) %>% 
mutate(Percent_total = n_networks_shared / n_distinct(data$Network_id)*100)
#Check number of studies under 1%
plant_total = nrow(plant_spread)
plants_under_one_percent = plant_spread %>% 
filter(Percent_total<1) %>% 
nrow()
plants_under_one_percent = plants_under_one_percent/plant_total * 100  
#Find most common plant
most_common_plant = plant_spread %>% 
filter(Percent_total == max(Percent_total)) %>% 
pull(Plant_accepted_name)
#Find most common plant percent
most_common_plant_percent = plant_spread %>% 
filter(Percent_total == max(Percent_total)) %>% 
pull(Percent_total)
```

## Sampling coverage 

The estimated sampling coverage of plant and pollinator species within EuPPollNet across the different sampling sites is approximately `r round(poll_coverage)`% for both taxonomic groups. This suggests that the rarefied accumulation curves of both plant and pollinator species exhibit already a "quasi-asymptotic" growth of species richness by considering the current number of sampling sites or networks (**Figure 4a-4b**). The predicted observed species richness by doubling the sampling effort on the already sampled habitat types within the database will only increase pollinator richness by `r format(round(poll_increase3, 2), nsmall=2)`% and plant richness by `r format(round(plant_increase3, 2), nsmall=2)`%. However, the sampling coverage of interactions is `r format(round(int_coverage, 2), nsmall=2)`%, and by doubling the sampling effort the predicted number of unique interactions recorded will have approximately a twofold increase (`r format(round(int_increase3, 2), nsmall=2)`%; **Figure 4c**). When we consider the accumulated pollinator richness across sampled plant species, this curve also shows a “quasi-asymptotic” growth with a sampling coverage value of `r format(round(plant_poll_coverage, 2), nsmall=2)`%. The predicted recorded pollinator species by doubling the number of plants sampled is expected to increase by `r format(round(plant_poll_increase3, 2), nsmall=2)`% (**Figure 4d**). We find that a small portion of plant species and pollinator species are shared across a broad range of sampling sites and that most plant (`r format(round(plants_under_one_percent, 2), nsmall=2)`%) and pollinator (`r format(round(polls_under_one_percent, 2), nsmall=2)`%) species are exclusively found in less than 1% of sampling sites (**Figures 4e-4f**). The most common plant (*`r most_common_plant`*) and pollinator (*`r most_common_poll`*) species are found in `r format(round(most_common_plant_percent, 2), nsmall=2)`% and `r format(round(most_common_poll_percent, 2), nsmall=2)`% of sampling sites, respectively.

```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="95%", fig.cap= "\\textbf{Figure 4}. Graphs (a-b-c) indicate the accumulation curves for pollinators, plants, and their interactions across sampling sites. Grey solid lines represent 100 randomized accumulation curves, the black solid lines represent the interpolated curve (i.e., the mean across curves), and the red dashed lines illustrate the extrapolated curve for approximately 3000 sampling sites. The solid black points indicate the number of species and interactions contained in the database. Graph (d) shows the accumulation curve of pollinator species across an increasing number of plant species. This last graph uses the same color and shape structure as the ones in the top panel. Graphs (e-f) indicate the percentage of occurrence (i.e., incidence) of plant and pollinator species across sampling sites. Species on the left (i.e., common) are found in many sampling sites, while species on the right (i.e., rare) are found in few or only a single sampling site. Note that indeed \\textit{Apis mellifera} is the most common pollinator but was excluded from this visualization.", fig.width=10, fig.height=6, out.width="115%"}

#Pollinators-----
poll_output = readRDS("../Data/Working_files/pollinator_sampling_coverage.rds")
pollinators_curves = readRDS("../Data/Working_files/collectors_curves_pollinators.rds")
#Create dataset
d_poll = poll_output$iNextEst$Network_id
#Check cols
d_poll$col = d_poll$method

#Now create tibble with same structure
a_poll = tibble(t = pollinators_curves$Study_sampled, 
           method = as.character(pollinators_curves$iteration), 
           qD = pollinators_curves$Unique_spp_cumulative,
           col = "collectors")

#Bind datasets 
d_poll1 = bind_rows(d_poll, a_poll)
d_poll1_point = d_poll1 %>%  filter(method == "observed")
d_poll1_lines = d_poll1 %>%  filter(!method == "observed")

#Order levels
d_poll1_lines$col = factor(d_poll1_lines$col, levels = c("collectors", "interpolated", "extrapolated"))
#Plot
p1 = ggplot(d_poll1_lines, aes(x = t, y = qD, group = method, color = col)) +
geom_line(aes(linetype = col),size = 0.65) +
scale_colour_manual(values = c("gray", "black", "red"), labels = c("Randomizations", "Interpolated", "Extrapolated")) +
scale_linetype_manual(values = c("solid", "solid", "dashed"),  labels = c("Randomizations", "Interpolated", "Extrapolated")) + 
geom_ribbon(aes(ymin = qD.LCL, 
    ymax=qD.UCL, fill = col),alpha=0.2, colour = NA, show.legend = FALSE)+
scale_fill_manual(values = c("gray", "black", "red")) +
geom_point(data = d_poll1_point, col = "black", size=2) + 
ylab("Pollinator species") +
xlab("Sampling sites") +
theme_bw() +
coord_cartesian(expand = FALSE, clip = "off")  +
xlim(0,3000)+
ylim(0, 3000) +
ggtitle("(a)") +
theme(plot.margin = margin(r = 12)) 

#Plants-----
plant_output = readRDS("../Data/Working_files/plant_sampling_coverage.rds")
plant_curves = readRDS("../Data/Working_files/collectors_curves_plants.rds")
#Create dataset
d_plant = plant_output$iNextEst$Network_id
#Check cols
d_plant$col = d_plant$method

#Now create tibble with same structure
a_plant = tibble(t = plant_curves$Study_sampled, 
           method = as.character(plant_curves$iteration), 
           qD = plant_curves$Unique_spp_cumulative,
           col = "collectors")

#Bind datasets 
d_plant1 = bind_rows(d_plant, a_plant)
d_plant1_point = d_plant1 %>%  filter(method == "observed")
d_plant1_lines = d_plant1 %>%  filter(!method == "observed")

#Order levels
d_plant1_lines$col = factor(d_plant1_lines$col, levels = c("collectors", "interpolated", "extrapolated"))
#Plot
p2 = ggplot(d_plant1_lines, aes(x = t, y = qD, group = method, color = col)) +
geom_line(aes(linetype = col), size = 0.65) +
scale_colour_manual(values = c("gray", "black", "red"), labels = c("Randomizations", "Interpolated", "Extrapolated")) +
scale_linetype_manual(values = c("solid", "solid", "dashed"),  labels = c("Randomizations", "Interpolated", "Extrapolated")) + 
geom_ribbon(aes(ymin = qD.LCL, 
    ymax=qD.UCL, fill = col),alpha=0.2, colour = NA, show.legend = FALSE)+
scale_fill_manual(values = c("gray", "black", "red")) +
geom_point(data = d_plant1_point, col = "black", size=2) + 
ylab("Plant species") +
xlab("Sampling sites") +
theme_bw() +
coord_cartesian(expand = FALSE, clip = "off")  +
xlim(0,3000)+
ylim(0, 3000)+
ggtitle("(b)")+
theme(plot.margin = margin(r = 12)) 



#Interactions-----
int_output = readRDS("../Data/Working_files/interactions_sampling_coverage.rds")
interactions_curves = readRDS("../Data/Working_files/collectors_curves_interactions.rds")
#Create dataset
d_int = int_output$iNextEst$Network_id
#Check cols
d_int$col = d_int$method

#Now create tibble with same structure
a_poll = tibble(t = interactions_curves$Study_sampled, 
           method = as.character(interactions_curves$iteration), 
           qD = interactions_curves$Unique_spp_cumulative,
           col = "collectors")

#Bind datasets 
d_int1 = bind_rows(d_int, a_poll)
d_int1_point = d_int1 %>%  filter(method == "observed")
d_int1_lines = d_int1 %>%  filter(!method == "observed")

#Plot
#Order levels
d_int1_lines$col = factor(d_int1_lines$col, levels = c("collectors", "interpolated", "extrapolated"))
#Plot
p3 = ggplot(d_int1_lines, aes(x = t, y = qD, group = method, color = col)) +
geom_line(aes(linetype = col), size = 0.65) +
scale_colour_manual(values = c("gray", "black", "red"), labels = c("Randomizations", "Interpolated", "Extrapolated")) +
scale_linetype_manual(values = c("solid", "solid", "dashed"),  labels = c("Randomizations", "Interpolated", "Extrapolated")) + 
geom_ribbon(aes(ymin = qD.LCL, 
    ymax=qD.UCL, fill = col),alpha=0.2, colour = NA, show.legend = FALSE)+
scale_fill_manual(values = c("gray", "black", "red")) +
geom_point(data = d_int1_point, col = "black", size=2) + 
ylab("Interactions") +
xlab("Sampling sites") +
theme_bw() +
coord_cartesian(expand = FALSE, clip = "off")  +
xlim(0,3000) +
ylim(0, 30000)+
ggtitle("(c)")

#----------------#
#Pollinators
#----------------#
#Read data
data = readRDS("../Data/Working_files/Interactions_uncounted.rds")%>% 
mutate(Network_id = paste0(Study_id, Network_id))  
#First select cols of rank, accepted name and study ID
#Then select unique levels by study ID
#Now sum levels (maximum can be as maximum number of studies)
poll_spread = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Network_id) %>% 
group_by(Network_id) %>% 
filter(Pollinator_rank == "SPECIES") %>% 
distinct(Pollinator_accepted_name) %>% 
ungroup() %>% 
count(Pollinator_accepted_name) %>% 
rename(n_networks_shared = n) %>% 
arrange(-n_networks_shared) %>% 
mutate(Percent_total = n_networks_shared / n_distinct(data$Network_id))
  
#Seelect quantile 50% from the total number of species
spp_number = poll_spread %>%  
select(Pollinator_accepted_name) %>% 
n_distinct()
df = seq(1, spp_number)
quantile_50 = quantile(df, 0.5)

#Obtain most common pollinator for plotting
most_common_poll = poll_spread %>% filter(n_networks_shared == max(n_networks_shared)) %>%
select(Pollinator_accepted_name) %>% pull() 

#Plot
o1 = ggplot(poll_spread, 
aes(reorder(Pollinator_accepted_name,-Percent_total), Percent_total)) +
geom_bar(stat = "identity", 
           color = "#D55E00",
           lwd = 0.03, fill = "#D55E00") +
ylab("Shared pollinators (%)") +
theme_minimal()+
theme(axis.text.x = element_blank(),
  axis.ticks.x=element_blank(),
  axis.ticks.y = element_line(size = 0.2),
  panel.grid.major.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.y = element_line(size=0.2, linetype = 2)) +
xlab("Pollinator species") +
ylab("Occurrence across sampling sites") + 
geom_vline(xintercept = quantile_50, linetype="dashed", 
color = "black", size=0.35) + 
annotate(geom="text", x=1450, y=0.60, label="50th percentile",color="black", size = 3) +
annotate(geom="text", x=140, y=0.67, label=most_common_poll[1],color="black",  fontface = 'italic', size = 3)+
annotate(geom="text", x=200, y=-0.05, label="Common spp."
      ,color="black",  size = 3) +
annotate(geom="text", x=1800, y=-0.05, label="\'Rare\' spp."
      ,color="black",  size = 3)  +
scale_y_continuous(breaks = seq(0, 0.7, by= 0.25), expand = c(0, 0)) + 
coord_cartesian(xlim=c(0, nlevels(factor(poll_spread$Pollinator_accepted_name))),
                ylim=c(0,0.7), clip="off") +
ggtitle("(e)")

#----------------#
#Plants
#----------------#
plant_spread = data %>% 
select(Plant_rank, Network_id, Plant_accepted_name) %>% 
group_by(Network_id) %>% 
filter(Plant_rank == "SPECIES") %>% 
distinct(Plant_accepted_name) %>% 
ungroup() %>% 
count(Plant_accepted_name) %>% 
rename(n_networks_shared = n) %>% 
arrange(-n_networks_shared) %>% 
mutate(Percent_total = n_networks_shared / n_distinct(data$Network_id))
  
#Seelect quantile 50% from the total number of species
spp_number = plant_spread %>%  
select(Plant_accepted_name) %>% 
n_distinct()
df = seq(1, spp_number)
quantile_50 = quantile(df, 0.5)

#Obtain most common plant for plotting
most_common_plant = plant_spread %>% filter(n_networks_shared == max(n_networks_shared)) %>%
select(Plant_accepted_name) %>% pull() 

o2 = ggplot(plant_spread, 
aes(reorder(Plant_accepted_name,-Percent_total), Percent_total, fill = Plant_accepted_name)) +
geom_bar(stat = "identity", 
           color = "#009E73",
           lwd = 0.03, fill = "#009E73") +
theme_minimal()+
theme(axis.text.x = element_blank(),
         axis.ticks.x=element_blank(),
         axis.ticks.y = element_line(size = 0.2),
         panel.grid.major.x = element_blank(),
         panel.grid.minor.y = element_blank(),
         panel.grid.major.y = element_line(size=0.2, linetype =  2)) +
xlab("Plant species") +
ylab("Occurrence across sampling sites") + 
geom_vline(xintercept = quantile_50, linetype="dashed", 
          color = "black", size=0.35) + 
annotate(geom="text", x=950, y=0.60, label="50th percentile",color="black", size = 3) + 
annotate(geom="text", x=100, y=0.4, label=most_common_plant[1]
      ,color="black",  fontface = 'italic', size = 3)+
annotate(geom="text", x=150, y=-0.05, label="Common spp."
      ,color="black",  size = 3) +
annotate(geom="text", x=1200, y=-0.05, label="\'Rare\' spp."
      ,color="black",  size = 3) + 
scale_y_continuous(breaks = seq(0, 0.7, by= 0.25), expand = c(0, 0), labels = label_number(accuracy = 0.01)) +
coord_cartesian(xlim=c(0, nlevels(factor(plant_spread$Plant_accepted_name))),
                ylim=c(0, 0.7), clip="off") +
ggtitle("(f)")

#Pollinator by plant species
plant_poll_curves = readRDS("../Data/Working_files/collectors_curves_plant_ploll.rds")
plant_poll_output = readRDS("../Data/Working_files/plant_poll_spp_sampling_coverage.rds")

#Create dataset
d_pp = plant_poll_output$iNextEst$Plant_id
#Check cols
d_pp$col = d_pp$method

#Now create tibble with same structure
a_poll = tibble(t = plant_poll_curves$Plant_sampled, 
           method = as.character(plant_poll_curves$iteration), 
           qD = plant_poll_curves$Unique_spp_cumulative,
           col = "collectors")

#Bind datasets 
d_pp1 = bind_rows(d_pp, a_poll)
d_pp1_point = d_pp1 %>%  filter(method == "observed")
d_pp1_lines = d_pp1 %>%  filter(!method == "observed")

#Plot
#Order levels
d_pp1_lines$col = factor(d_pp1_lines$col, levels = c("collectors", "interpolated", "extrapolated"))
#Plot
pp1 = ggplot(d_pp1_lines, aes(x = t, y = qD, group = method, color = col)) +
geom_line(aes(linetype = col)) +
scale_colour_manual(values = c("gray", "black", "red"), labels = c("Randomizations", "Interpolated", "Extrapolated")) +
scale_linetype_manual(values = c("solid", "solid", "dashed"),  labels = c("Randomizations", "Interpolated", "Extrapolated")) + 
geom_ribbon(aes(ymin = qD.LCL, 
    ymax=qD.UCL, fill = col),alpha=0.2, colour = NA, show.legend = FALSE)+
scale_fill_manual(values = c("gray", "black", "red")) +
geom_point(data = d_pp1_point, col = "black") + 
ylab("Pollinator species") +
xlab("Plant species") +
theme_bw() +
coord_cartesian(expand = FALSE, clip = "off") +
ggtitle("(d)") +
scale_x_continuous(breaks = seq(0, 2800, by = 1000), limits=c(0,2800)) +
scale_y_continuous(breaks = seq(0, 2600, by = 1000), limits=c(0,2600)) +
theme(legend.position = "none")

#Plot all
p1 + p2 + p3 + pp1 + o1 + o2 + plot_layout(guides = "collect", nrow = 2, ncol=3) & theme(legend.title=element_blank(),
      axis.title = element_text(size=12, face = "bold"),
      axis.text = element_text(size=10),
      plot.title = element_text(size=18))

#a/b


```

\newpage

## Habitat type and bioclimatic region

The proportion of species from the major pollinator orders within the database differed across habitats and bioclimatic regions (**Figure 5**). As expected, Hymenoptera was the main taxonomic order on the majority of habitats, exceeded only by Diptera on the habitat categories of riparian vegetation, moors and heathland, and alpine grasslands. Overall, the proportion of Lepidoptera and Coleoptera species was low across all habitats but Coleoptera showed a notably increase in sclerophyllous vegetation and beaches, dunes and sands habitat categories. Similar patterns were observed when exploring the pollinator proportions by bioclimatic region. In this particular case, Hymenoptera was the predominant order in all bioclimatic regions with Diptera taking more importance in Alpine and Atlantic regions. Lepidoptera shows low proportions across all bioclimatic regions and Coleoptera is only relevant in Mediterranean regions at European level. Notably, the number of studies (**Figure 5**) and sampling sites (**Figure S2**) also differs across habitats and bioclimatic regions. The habitats sampled by a higher number of studies in the database are `r studies_by_habitat$EuPPollNet_habitat[[1]]` (`r studies_by_habitat$Habitat_count[[1]]`), `r studies_by_habitat$EuPPollNet_habitat[[2]]` (`r studies_by_habitat$Habitat_count[[2]]`) and `r studies_by_habitat$EuPPollNet_habitat[[3]]` (`r studies_by_habitat$Habitat_count[[3]]`). However, the habitats that contain a higher number of sampling sites are `r networks_by_habitat$EuPPollNet_habitat[[1]]` (`r networks_by_habitat$Habitat_count[[1]]`), `r networks_by_habitat$EuPPollNet_habitat[[2]]` (`r networks_by_habitat$Habitat_count[[2]]`) and `r networks_by_habitat$EuPPollNet_habitat[[3]]` (`r networks_by_habitat$Habitat_count[[3]]`). The bioclimatic regions with a higher number of studies are `r studies_by_bioregion$Bioregion[[1]]` (`r studies_by_bioregion$Bioregion_count[[1]]`), `r studies_by_bioregion$Bioregion[[2]]` (`r studies_by_bioregion$Bioregion_count[[2]]`) and `r studies_by_bioregion$Bioregion[[3]]` (`r studies_by_bioregion$Bioregion_count[[3]]`); and the ones that contain a higher number of sampling sites are `r networks_by_bioregion$Bioregion[[1]]` (`r networks_by_bioregion$Bioregion_count[[1]]`), `r networks_by_bioregion$Bioregion[[2]]` (`r networks_by_bioregion$Bioregion_count[[2]]`) and `r networks_by_bioregion$Bioregion[[3]]` (`r networks_by_bioregion$Bioregion_count[[3]]`). 


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="95%", fig.cap= "\\textbf{Figure 5}. Proportion of species from the major pollinator orders by habitat types and bioclimatic regions in the EuPPollNet database. The orders, from left to right, include Hymenoptera, Diptera, Lepidoptera and Coleoptera. The horizontal barplot on the right indicates the number of studies that were conducted on each habitat type or bioclimatic region. Note that a single study can contribute to more than one habitat or bioclimatic region. Areas with a greater number of studies are more likely to depict accurate proportions of the different pollinator orders in those systems.", fig.width=4.5, fig.height=8, fig.align='center'}


#Prepare orders for filtering
main_orders = c("Hymenoptera", "Lepidoptera", "Coleoptera", "Diptera")

#Karise is a very large study that only sampled bumblebees and
#is providing unrealistic results for the Boreal region
#Filter out
#Maybe add to caption?
data1 = data %>% 
filter(!Study_id == "13_Karise")

#Check number of studies by habitat
habitat = data1 %>% 
select(Study_id, EuPPollNet_habitat) %>% 
distinct() %>%  
group_by(EuPPollNet_habitat) %>% 
summarise(Habitat_count = n()) 
#Check number of studies by bioregion
bioregion = data1 %>% 
select(Study_id, Bioregion) %>% 
distinct() %>%  
group_by(Bioregion) %>% 
summarise(Bioregion_count = n()) 
#Check pols by habitat
pollinator_percent = data1 %>%
group_by(EuPPollNet_habitat, Pollinator_order) %>%
filter(Pollinator_accepted_name!= "Apis mellifera") %>% 
filter(Pollinator_order %in% main_orders) %>% 
summarise(count = n()) %>%
group_by(EuPPollNet_habitat) %>%
mutate(Proportion = count/sum(count)) %>%
select(-count) 
#Check pols by bioregion
pollinator_percent_bio = data1 %>%
group_by(Bioregion, Pollinator_order) %>%
filter(Pollinator_accepted_name!= "Apis mellifera") %>% 
filter(Pollinator_order %in% main_orders) %>% 
summarise(count = n()) %>%
group_by(Bioregion) %>%
mutate(Proportion = count/sum(count)) %>%
select(-count) 
#Preparing datasets for horizontal plot
a1 = habitat %>% 
mutate(Group = "Habitat") %>% 
rename(Habitat = EuPPollNet_habitat) %>% 
rename(Count = Habitat_count)

b1 = bioregion %>% 
mutate(Group = "Bioregion") %>% 
rename(Habitat = Bioregion) %>% 
rename(Count = Bioregion_count)

#Bind datasets
c1 = bind_rows(a1,b1)

#Create datasets and rename cols
a2 = pollinator_percent_bio %>% 
mutate(Group = "Bioregion") %>% 
rename(Habitat = Bioregion) 

b2 = pollinator_percent %>% 
mutate(Group = "Habitat") %>% 
rename(Habitat = EuPPollNet_habitat)
#Bind rows
c2 = bind_rows(a2, b2) 

#Prepare to set ordered labels
l2 = c2 %>% 
filter(Pollinator_order == "Hymenoptera") %>% 
arrange((Proportion)) %>% 
pull(Habitat)
#Set order of labels
c2$Habitat = factor(c2$Habitat, levels = l2)

#Set the right order of labels
c2$Pollinator_order = factor(c2$Pollinator_order, levels = c("Hymenoptera", "Diptera", "Lepidoptera", "Coleoptera"))


p1 = ggplot(c2, 
aes(fill=Pollinator_order, y=Proportion, x=Habitat)) + 
geom_bar(position = position_stack(reverse = TRUE), stat="identity")+
theme_bw() +
theme(legend.position = "bottom",
      plot.margin=unit(c(0,0,0,0), "mm"),
      legend.text = element_text(size=6),
      legend.key.size = unit(2, "mm"),
      legend.spacing.y = unit(0.1, "cm"),
       legend.box.spacing = unit(0, "pt"),
      axis.title = element_text(face = "bold", size = 7),
      axis.text = element_text(size=6),
      panel.border = element_rect(size=1)) +
xlab(NULL) +
ylab("Proportion of species") +
scale_y_continuous(breaks = c(0.25, 0.5,0.75), labels = c("0.25", "0.5","0.75"))+
theme(strip.text.x = element_text(size = 10, face = "bold"),
    strip.background = element_rect(
color=NA, fill=NA, size=0.5, linetype="solid")) +
scale_fill_manual(values = viridis(4),
                  name = NULL) +
coord_flip(expand = FALSE) +
ggforce::facet_col(~ factor(Group, levels=c("Habitat","Bioregion")), space = "free", scales = "free_y") +
guides(fill=guide_legend(nrow=2,byrow=TRUE)) 

#Unify labels
c1$Habitat = factor(c1$Habitat, levels = l2)

#Create barplot on the side
p2 =ggplot(c1, aes(Habitat, Count)) +
geom_col(fill = "gray25",width = 0.9, color="black", linewidth = 0.4) +
theme_light() +
theme(plot.margin=unit(c(0,0,0,0), "mm"),
      axis.ticks.y = element_blank(), 
      axis.ticks.x = element_line(color="black"),
  axis.text.y = element_blank(), 
      strip.text.x = element_text(size=12),
      strip.background = element_rect(
color=NA, fill=NA, size=0.5, linetype="solid"),
  axis.title = element_text(face = "bold", size = 7),
axis.text = element_text(size=6)) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(),
panel.border = element_blank(),
axis.line = element_line(color = 'black'),
plot.margin = margin(0,0,0,0)) +
scale_y_continuous(breaks = c(0, 10,20), labels = c("0", "10","20"), limits = c(0,30))+
xlab(NULL) +
ylab("Number of studies")+
theme(legend.position = "none")+
coord_flip(expand = F) +
ggforce::facet_col(~ factor(Group, levels=c("Habitat","Bioregion")), space = "free", scales = "free_y")


#Plot panel
p1 + p2 + plot_layout(widths = c(4,2, 2.5),heights= c(10,10,4), ncol=2) 


```

\newpage

```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE}

#Outputs calculated in script 7_3
#Load lm output connectance ~ latitude
connectance_lat_r2= readRDS("../Data/Manuscript_info/connectance_lat_r2.rds")
connectance_lat_pval = readRDS("../Data/Manuscript_info/connectance_lat_pval.rds")
#Load lm output nestedness ~ latitude
normalised_nestedness_lat_r2 = readRDS("../Data/Manuscript_info/normalised_nestedness_lat_r2.rds")
normalised_nestedness_lat_pval = readRDS("../Data/Manuscript_info/normalised_nestedness_lat_pval.rds")
#Load values of connectance
min_connectance = readRDS("../Data/Manuscript_info/min_connectance.rds")
max_connectance = readRDS("../Data/Manuscript_info/max_connectance.rds")
mean_connectance = readRDS("../Data/Manuscript_info/mean_connectance.rds")
#Load values of nestedness
min_nodfc = readRDS("../Data/Manuscript_info/min_nodfc.rds")
max_nodfc = readRDS("../Data/Manuscript_info/max_nodfc.rds")
mean_nodfc = readRDS("../Data/Manuscript_info/mean_nodfc.rds")
#Load kendall corr from connectance and spp
connectance_spp_mean_corr_tau = readRDS("../Data/Manuscript_info/connectance_spp_mean_corr_tau.rds")
connectance_spp_mean_corr_pval = readRDS("../Data/Manuscript_info/connectance_spp_mean_corr_pval.rds")
#Load kendall corr from nestedness and spp
normalised_nestedness_spp_mean_corr_tau = readRDS("../Data/Manuscript_info/normalised_nestedness_spp_mean_corr_tau.rds")
normalised_nestedness_spp_mean_corr_pval = readRDS("../Data/Manuscript_info/normalised_nestedness_spp_mean_corr_pval.rds")
#Load z values
#Save data
z_percent = readRDS("../Data/Manuscript_info/z_percent.rds")
no_diff_z_percent = z_percent %>% 
filter(infra_over_represented == "No statistical difference") %>% 
pull(percent)
over_z_percent = z_percent %>% 
filter(infra_over_represented == "Over-represented") %>% 
pull(percent)
under_z_percent = z_percent %>% 
filter(infra_over_represented == "Under-represented") %>% 
pull(percent)
#Load correlation outputs of residual connectance and nestednes
resid_connectance_nestedness_corr_tau = readRDS("../Data/Manuscript_info/resid_connectance_nestedness_tau.rds")
resid_connectance_nestedness_corr_pval = readRDS("../Data/Manuscript_info/resid_connectance_nestedness_pval.rds")


```

## Network properties

Connectance values ranged between `r round(min_connectance, 2)` to `r round(max_connectance, 2)` ($\bar{x}$ = `r round(mean_connectance, 2)`) and as expected, followed an negative exponential relationship with the number of species per network (Kendall $\tau$ = `r round(connectance_spp_mean_corr_tau, 2)`, _P_ < 0.01; **Figure 6a**). Nestedness values (NODFc) ranged between `r round(min_nodfc, 2)` to `r round(max_nodfc, 2)` ($\bar{x}$ = `r round(mean_nodfc, 2)`), and as expected for this metric, were independent of the mean number of species (Kendall $\tau$ = `r round(normalised_nestedness_spp_mean_corr_tau, 2)`, _P_ = `r round(normalised_nestedness_spp_mean_corr_pval, 2)`; **Figure S3**). We found that only `r round(over_z_percent, 2)`% of networks were statistically more nested than expected by chance, with `r round(no_diff_z_percent, 2)`% showing no statistical difference, and none being less nested than null expectations (**Figure 6b**). Latitude explained little of the observed variability of residual connectance and nestedness across networks (connectance: R$^2$ = `r round(connectance_lat_r2, 2)`, _P_ = `r round(connectance_lat_pval, 2)`, **Figure 6a**; NODFc: R$^2$ = `r round(normalised_nestedness_lat_r2, 2)`, _P_ = `r round(normalised_nestedness_lat_pval, 2)`, **Figure 6b**). Overall, networks towards higher latitudes showed lower residual connectance and higher nestedness than networks located in lower latitudes. Note that residual connectance and normalised nestedness showed a moderate negative correlation (Kendall $\tau$ = `r round(resid_connectance_nestedness_corr_tau, 2)`, _P_ = `r round(resid_connectance_nestedness_corr_pval, 2)`).


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="95%", fig.cap= "\\textbf{Figure 6}. Graph (a) shows the association between network connectance and the geometric mean of plant and pollinator species per network on a log-scale with the respective fitted line from a Beta regression. Graph (b) shows the distribution of z-scores when comparing the nestedness from the empirical networks with their randomised counterparts (100 null models for each network). The vertical red dashed lines represent the z critical value for a two tailed test with alpha = 0.05. Z-scores to the left of the first vertical red dashed line indicate that networks are less nested than expected by chance (red), those between the two dashed lines indicate no statistical difference from random expectations (green), and those to the right indicate that networks are more nested than expected by chance (blue). Graphs (c-d) show the fitted regression of residual connectance and nestedness across the latitudinal range of the studies from the database. In addition, the bioclimatic region of each network is indicated with points of different shapes and colours.", fig.width=10, fig.height=7, fig.align='center'}

# Load libraries
library(dplyr)
library(ggplot2)
library(stringr)
library(patchwork)

# Load plots generated in scripts 7_2_Nestedness and 7_2_Connectance

connectance_species = readRDS("../Data/Manuscript_info/Figure6_connectance_species.rds")
connectance_latitude = readRDS("../Data/Manuscript_info/Figure6_connectance_latitude.rds")
nestedness_z_scores = readRDS("../Data/Manuscript_info/nestedness_z_scores.rds")
nestedness_latitude = readRDS("../Data/Manuscript_info/nestedness_latitude.rds")

#Prepare first connectance plots
library(betareg)
model = betareg(Connectance ~ log_geometric_mean_spp, data = connectance_species)
p1 = ggplot(connectance_species, aes(x = log_geometric_mean_spp, y = Connectance))+
geom_point(pch = 21, fill = "azure3", size=2.5) +
geom_line(aes(y = predict(model, connectance_species)), colour= "black")+
xlab("log(Species)") +
theme_bw() +
ggtitle("(a)")


p3 = connectance_latitude %>% 
ggplot(aes(Latitude, residual_conectance)) +
geom_point(aes(fill = Bioregion, shape = Bioregion), stroke = 0.25, size=2.5) +
scale_fill_viridis_d() +
scale_colour_viridis_d() +
scale_shape_manual(values = c(
  "Alpine" = 21,  # Circle
  "Atlantic" = 22, # Triangle
  "Boreal" = 23,   # Square
  "Continental" = 24,  # Diamond
  "Mediterranean" = 25  # Cross
  )) +
geom_line(data = connectance_latitude,aes(x=Latitude, y = fit), inherit.aes = FALSE)+
geom_ribbon(data = connectance_latitude, 
    aes(x=Latitude,ymin = lwr, ymax = upr), inherit.aes = FALSE,
    fill = "grey70", alpha= 0.3) +
theme_bw()+
ylab("Residual connectance") +
ggtitle("(c)")



#Prepare now nestedness plots
# Plot
p = 0.05 #cutoff probability 95% confidence
critical_value = qnorm(p/2) #double tail probability divide by 2

nestedness_z_scores = nestedness_z_scores %>%
mutate(infra_over_represented = case_when(
z_score < -abs(critical_value) ~ "Under-represented",
between(z_score, -abs(critical_value), abs(critical_value)) ~ "No statistical difference",
    z_score > abs(critical_value) ~ "Over-represented"
  ))

p2 = nestedness_z_scores %>% 
ggplot(aes(x = z_score)) +
geom_histogram(aes(y = ..density.., fill = infra_over_represented), 
               bins = 100, alpha = 0.5, color = "black", position = "stack") +
stat_function(data = nestedness_z_scores, fun = function(x) dnorm(x, mean = mean(nestedness_z_scores$z_score), sd = sd(nestedness_z_scores$z_score)) * 1.7, 
              n = 1000, inherit.aes = FALSE, color = "gray18", size = 1) +
theme_bw() +
coord_cartesian(expand = FALSE) +
geom_vline(xintercept = -abs(critical_value), linetype = "longdash", colour = "red") +
geom_vline(xintercept = abs(critical_value), linetype = "longdash", colour = "red") +
ylab("Density") +
xlab("Z scores (NODF)")  +
xlim(-6, 9) +
ylim(0, 0.8) +
scale_fill_manual(name = "Observed against null",
                  limits = c("Under-represented", "No statistical difference", "Over-represented"),
                  labels = c("Less nested", "No difference", "More nested"),
                  values = c("Under-represented" = "coral2", 
                             "No statistical difference" = "palegreen3", 
                             "Over-represented" = "cyan3")) +
ggtitle("(b)")


# 2nd Plot
p4 = nestedness_latitude %>% 
ggplot(aes(Latitude, Normalised_nestedness)) +
geom_point(aes(fill = Bioregion, shape = Bioregion), stroke = 0.25, size=2.5) +
theme_bw() +
ylab("NODFc") +
scale_fill_viridis_d() +
scale_colour_viridis_d() +
scale_shape_manual(values = c(
  "Alpine" = 21,  # Circle
  "Atlantic" = 22, # Triangle
  "Boreal" = 23,   # Square
  "Continental" = 24,  # Diamond
  "Mediterranean" = 25  # Cross
  )) +
geom_line(data = nestedness_latitude,aes(x=Latitude, y = fit), inherit.aes = FALSE)+
geom_ribbon(data = nestedness_latitude, 
    aes(x=Latitude,ymin = lwr, ymax = upr), inherit.aes = FALSE,
    fill = "grey70", alpha= 0.3) +
theme_bw()+
ggtitle("(d)")


# Layout plots
#a = (p1 + p2) 
#b = p3 + p4 + plot_layout(guides = 'collect') & theme(legend.position = "right")
#a / b

# Layout plots
a = (p1 + p2)  & theme(legend.position = "right", legend.justification = "left")
b = p3 + p4 + plot_layout(guides = 'collect') & theme(legend.justification = "left")
a / b  & theme(axis.title =  element_text(size=16, face="bold"),
               plot.title = element_text(size=22),
               panel.border = element_rect(colour = "black",
               fill=NA, size=1),
               axis.text=element_text(size=12))

```


\newpage 

# 3 | DISCUSSION

EuPPollNet offers the largest set of plant-pollinator studies and networks compiled to date at European level. The database contains `r prettyNum(plant_spp_number, big.mark=",")` plant and `r prettyNum(pollinator_spp_number, big.mark=",")` pollinator species with over a million interaction records. While the overall sampling coverage of species and interactions is relatively high across the sampled sites, the taxonomic coverage of plants and the main pollinator groups at the European level is still relatively low (i.e., `r round(plant_coverage, 1)`% for flowering plants and `r round(bee_coverage, 1)`% for bee species). This likely reflects the fact that most plant and pollinator species are rare and geographically restricted. For example given that most of the plant-pollinator networks from the database are sampled on intensive grasslands, and habitat heterogeneity is a crucial factor in understanding pollinator diversity at European level [@kleijn2015; @hass2018; @martinez2022], adding studies on other habitat types is likely to result in a rapid increase of the coverage of plant and pollinator species and their interactions. Indeed, plant and pollinator species were rarely shared across multiple sites, indicating that there are few "common" species and many "rare" ones at the metaweb or continental level. This high number of "rare" species results in an upward slope of the species or interaction accumulation curves [@thompson2003]. In other words, minimal sampling efforts are capturing a substantial number of species and interactions, but achieving a comprehensive inventory will require numerous sampling events within and across habitats, particularly for plant-pollinator interactions.

Bees are responsible for the majority of the interactions at the metaweb level, but their relative relevance changed across habitats and bioclimatic regions. For instance, plant-pollinator communities in the Mediterranean were dominated by bees, while communities in Alpine or Boreal regions were fly species rich or fly-dominated. These patterns are consistent with our current understanding of bee diversity, which peaks in dry or temperate areas [@orr2021; @leclercq2023]; and with the fact that colder environments (i.e., altitude and latitude wise) harbor a larger fraction of fly pollinators compared to other taxa [@elberling1999; @lefebvre2018]. In addition, beetles were only common floral visitors in the Mediterranean region. Although the networks from the database are visitation networks and do not capture pollinator efficiency [@ballantyne2015], the high proportion of beetles as floral visitors in the Mediterranean provides further support for their potential role as pollinators in this region [@herrera2019; @leon2022]. The number of butterfly species and interactions were relatively low compared to the other taxa. While Europe contains fewer butterfly species than other regions of the world [@ollerton2017], their relevance as pollinators is likely underestimated within this database. This is because a large fraction of studies (~40%) did not sample butterflies, and conventional sampling methods for monitoring other insect pollinators (e.g., bees or flies) may be inadequate for sampling plant-butterfly interactions [@isaac2011]. On the contrary, honey bees were present in `r round(apis_percent_networks, 1)`% of networks and conducted on average a third of the total interactions per network. Indeed, this proportion is higher than the one found when considering only natural communities at a global scale [~13%\; @hung2018], which highlights their key role as potential pollinators of many flowering plants. However, the rise of beekeeping in Europe has led to high honey bee densities, which can negatively impact wild pollinators and the plants they visit [@steffan2000; @magrach2017; @herrera2020], emphasising the need to evaluate these impacts and implement actions if necessary.

Although Europe contains a much larger number of flowering plants than pollinator species (~4 to 1 ratio), the observed number of pollinator species almost doubled the one of plants in the database. This could be explained by the fact that all networks are phytocentric, resulting in sampling bias towards pollinator species [@jordano2016; @vizentin2018]. While animal-centred sampling is likely to increase the plant:pollinator species ratio [e.g., @encinas2023], the spatial scale and environmental context of the sampled communities will also influence their observed diversity, especially given the ability to move of pollinators and the sessile nature of plants. EXPAND HERE!




Consistent with @olesen2002, we find that residual connectance (i.e., the deviation from the expected connectance for a given network size) was lower at higher latitudes, while normalised nestedness, which is negatively correlated with residual connectance, increased towards higher latitudes. Networks at lower latitudes in Europe are exposed to higher temperatures and are bee-dominated, which can result in higher visitation rates [@arroyo1985; @classen2015; @herrera2019], and the overall level of pollinator generalization is known to be higher at lower latitudes [@schleuning2012]. These factors should increase the possible number of connections that can be established between plants and pollinators for a given network size, resulting in more connected networks but less nested ones, as these networks are likely to deviate more from a perfect nested or hierarchical structure compared to networks at higher latitudes. Finally, while one third of networks were more nested than expected by chance, two thirds did not show statistical difference with null expectations. Therefore, while this supports the idea that plant-pollinator networks tend to be nested [@bascompte2003], this result suggests that nestedness could be a less prevalent feature than previously thought for plant-pollinator networks.

Despite this database covering a wide range of habitats across `r country_number` countries, it contains geographical biases that can impact our understanding of plant-pollinator communities [@hughes2021]. For instance, most plant-pollinator networks belong to central Europe, while Eastern Europe and the Mediterranean region are under-represented. This is consistent with previous studies which also report lack of plant-pollinator data for those regions [@bennett2018; @marshall2024], highlighting that this database shows existing patterns in data availability despite the absence of a systematic search for studies. This is especially relevant as Eastern Europe currently has vast landscapes of high quality semi-natural grasslands but is experiencing rapid land use change [@sutcliffe2015], and the Mediterranean region is likely to be severely impacted by climate change [@jaworski2022; @duchenne2020; @pareja2023]. These areas are well known for their rich pollinator diversity [@milivcic2018; @reverte2023], and their under-representation is likely contributing to the low taxonomic coverage of this database at the European level. Although some of the most well studied countries in Europe (e.g., Belgium, The Netherlands) have already experienced land use change and biodiversity loss at the end of the 20th century [@carvalheiro2013], plant-pollinator communities in Europe and across the globe still face current and future threats from climate change [@bartomeus2011; @duchenne2020], land use change [@reidsma2006; @batary2015], or the introduction of alien species [@vila2009; @vanbergen2018]. Therefore, continuous monitoring programs are needed in order to evaluate spatio-temporal changes of species and their interactions across different European habitats and regions. This will allow local and large scale analyses of the status and trends of plant-pollinator communities, effectively informing management and conservation actions.

In conclusion, the EuPPollNet database enables researchers to explore spatial, taxonomic and structural properties of plant-pollinator networks within Europe. In contrast to previous databases, EuPPollNet provides interaction data along with sampling information that could help researchers to better control for sampling effort and completeness and to select the most suitable networks for their research questions. Here, we have shown how connectance and nestedness change across their latitudinal range and that nestedness is not a ubiquitous feature of all plant-pollinator networks. These analyses aim to highlight the variability present across Europe in the structure of plant-pollinator networks and illustrate the  opportunities available to develop and test questions about spatio-temporal network change using EuPPollNet. The reproducible workflow allows researchers to adapt and reuse this database, enabling the continuous addition of new networks to better evaluate the status and trends of plant-pollinator communities. Finally, we hope this database becomes an iterative resource that keeps growing and improving over time to better understand and conserve European biodiversity.


\newpage

# REFERENCES

::: {#refs}
:::


# ACKNOWLEDGEMENTS

We thank all the taxonomist and ecologist that has made this database possible by contributing with their fieldwork data. 

# FUNDING INFORMATION

This research was funded by the H2020 European project Safeguard (101003476) and by the Federal State of Saxony-Anhalt (MLU-BioDivFund).

# CONFLICT OF INTEREST

None.

# DATA AVAILABILITY

All data and code to produce of this database and manuscript are available at Zenodo (LINK) and Github (LINK).

\newpage

# SUPPORTING INFORMATION

**Title**: EuPPollNet: A European database of plant-pollinator networks

**Authors**: `r authors`

**Contains**:

- Supplementary text 1

- Figure S1

- Figure S2

- Figure S3


\newpage

**Supplementary text 1**

Habitat definitions:

1) **Ruderal vegetation**: Plants growing on highly disturbed sites such as road sides or mineral extraction sites. 

2) **Agricultural margins**: Sides of crops that can include any type of vegetation from low growing plants to trees.

3) **Green urban areas**: Parks, private gardens or small pastures within an  urban setting. Botanical gardens are included in this category.

4) **Agricultural land**: Includes any type of crop and any type of vegetation growing within them. 

5) **Forest/woodland understory**: Any plant community sampled under a wooded group of plants. The forest could be embedded in an agricultural setting or in a fully natural scenario. We have included in this category agro-forestry areas and open to dense forest. Note that we have excluded from this category forest that contains sclerophyllous vegetation. 

6) **Semi-natural grassland**: Low growing plant community with relatively low disturbances but under low pressure such as seasonal mowing or extensive grazing.

7) **Intensive grassland**: Any type of low growing plant community that is highly influenced by human disturbance. For instance, agriculture, mowing, moderate to high grazing or urban environments. Note that this category also includes old pastures with regrowth of woody vegetation.

8) **Sclerophyllous vegetation**: Any type of system with a dominant shrub community adapted to drought. Typical of the Mediterranean region. Note, that we have included in this category also woodlands (open coniferous forest) where the shrub community was the main focus of the study.

9) **Beaches, dunes, sands**: Plant communities growing on sandy soil.

10) **Riparian vegetation**: Plant communities growing on river margins. 

10) **Alpine grasslands**: Low growing plant communities with little or none human disturbance. Often located in high elevation areas within Europe.

12) **Moors and heathland**: Low growing woody vegetation characteristic from low fertile soils near the coast or in alpine areas.


\newpage


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="105%", fig.cap= "\\textbf{Figure S1}. Coverage of the EuPPollNet species for bees (family level), syrphids (subfamily level) and butterflies (family level) in relation to the total number of European species within these taxonomic groups.", fig.width=10, fig.height=4}

#Prepare figure for supplementary material
#Coverage across high taxonomic ranks of bees, syrphids and butterflies
#--------------------------------------------------------------------------------------------#
#Start from bees----
#Bee families
bee_fam = c("Apidae", "Megachilidae", "Halictidae", 
            "Andrenidae", "Colletidae","Melittidae")


#Species per family within SafeNet
bee_spp_safenet = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Pollinator_order, Pollinator_family)%>%
filter(Pollinator_rank == "SPECIES") %>% 
filter(Pollinator_order == "Hymenoptera") %>% 
filter(!Pollinator_accepted_name == "Apis mellifera") %>% 
filter(Pollinator_family %in% bee_fam) %>% 
group_by(Pollinator_family) %>% 
summarise(Spp_number = n_distinct(Pollinator_accepted_name)) %>% 
mutate(Group = "EuPPollNet")
#Species per family within Europe
bee_spp_europe =  master_list %>% 
select(Family, Genus, Species, GenusAndSpecies) %>% 
filter(Family %in% bee_fam) %>% 
group_by(Family) %>% 
summarise(Spp_number = n_distinct(GenusAndSpecies)) %>% 
rename(Pollinator_family = Family) %>% 
mutate(Group = "Europe")

#Bind both datasets for plotting
bee_fam_coverage = bind_rows(bee_spp_safenet, bee_spp_europe)

p1 = ggplot(bee_fam_coverage, aes(reorder(Pollinator_family,-Spp_number), Spp_number, fill = Group)) +
geom_bar(stat="identity", width=.5, position = "dodge", color = "black") +
coord_cartesian(expand = FALSE) +
xlab(NULL) +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust =1),
      panel.border = element_rect(size=1)) +
ylab("Number of species") +
scale_fill_manual(values = c("tan2", "lightgrey"))+
ggtitle("Bee family coverage")
#--------------------------------------------------------------------------------------------#
#Continue with syrphids----
#As we don't have subfamilies, let's obtained them from the master list
syrphids = master_list %>% 
filter(Family == "Syrphidae") %>% 
select(Family,Subfamily,  Genus, Species, GenusAndSpecies) %>% 
rename(Pollinator_accepted_name = GenusAndSpecies)
#Syrphid species safenet
syrphid_spp_safenet = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Pollinator_order, Pollinator_family)%>%
filter(Pollinator_rank == "SPECIES") %>% 
filter(Pollinator_family== "Syrphidae") %>% 
distinct()
#Add subfamily info
syrphid_spp_safenet = left_join(syrphid_spp_safenet, syrphids)
#Summarise spp per subfamily
syrphid_spp_safenet = syrphid_spp_safenet %>% 
group_by(Subfamily) %>% 
summarise(Spp_number = n_distinct(Pollinator_accepted_name)) %>% 
mutate(Group = "EuPPollNet")
#Get spp per subfamily at european level
syrphid_spp_europe = master_list %>% 
filter(Family == "Syrphidae") %>% 
select(Family, Subfamily, Genus, Species, GenusAndSpecies) %>% 
group_by(Subfamily) %>% 
summarise(Spp_number = n_distinct(GenusAndSpecies)) %>% 
mutate(Group = "Europe")
#Bind both datasets for plotting
syrphid_fam_coverage = bind_rows(syrphid_spp_safenet, syrphid_spp_europe)
#Plot
p2 = ggplot(syrphid_fam_coverage, aes(reorder(Subfamily,-Spp_number), Spp_number, fill = Group)) +
geom_bar(stat="identity", width=.5, position = "dodge", color = "black") +
coord_cartesian(expand = FALSE) +
xlab(NULL) +
ylab(NULL) +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust =1),
      panel.border = element_rect(size=1)) +
scale_fill_manual(values = c("tan2", "lightgrey"))+
ggtitle("Syrphid subfamily coverage")
#--------------------------------------------------------------------------------------------#
#Continue with butterflies----
#Do it at family level
#Create vector with butterfly families
butt_fam = c(unique(master_list1$family))
#Species per family within SafeNet
butterfly_spp_safenet = data %>% 
select(Pollinator_rank, Pollinator_accepted_name, Pollinator_order, Pollinator_family)%>%
filter(Pollinator_rank == "SPECIES") %>% 
filter(Pollinator_order == "Lepidoptera") %>% 
filter(Pollinator_family %in% butt_fam) %>% 
group_by(Pollinator_family) %>% 
summarise(Spp_number = n_distinct(Pollinator_accepted_name)) %>% 
mutate(Group = "EuPPollNet")
#Species per family within Europe
butterfly_spp_europe =  master_list1 %>% 
select(family, genus, scientificName) %>% 
group_by(family) %>% 
summarise(Spp_number = n_distinct(scientificName)) %>% 
rename(Pollinator_family = family) %>% 
mutate(Group = "Europe")
#Bind both datasets for plotting
butterfly_fam_coverage = bind_rows(butterfly_spp_safenet, butterfly_spp_europe)
#Plot
p3 = ggplot(butterfly_fam_coverage, aes(reorder(Pollinator_family,-Spp_number), Spp_number, fill = Group)) +
geom_bar(stat="identity", width=.5, position = "dodge", color = "black") +
coord_cartesian(expand = FALSE) +
xlab(NULL) +
ylab(NULL) +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust =1),
      panel.border = element_rect(size=1)) +
scale_fill_manual(values = c("tan2", "lightgrey"))+
ggtitle("Butterfly family coverage")

#--------------------------------------------------------------------------------------------#
p1+p2+p3 + plot_layout(guides = "collect") & 
theme(plot.title = element_text(size = 14, face = "bold"),
      axis.title = element_text(face = "bold", size = 14),
      axis.text = element_text(face = "bold", size = 12))


```


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="90%", fig.cap= "\\textbf{Figure S2}. Barplot indicating the number of sampling sites by habitat and bioclimatic region within the database.", fig.width=8, fig.height=8}

#Check number of studies by habitat
habitat = data %>% 
select(Network_id, EuPPollNet_habitat) %>% 
distinct() %>%  
group_by(EuPPollNet_habitat) %>% 
summarise(Habitat_count = n()) %>% 
mutate(Group = "Habitat") %>% 
rename(Habitat_bioregion = EuPPollNet_habitat) %>% 
rename(Count = Habitat_count)

#Check number of studies by bioregion
bioregion = data %>% 
select(Network_id, Bioregion) %>% 
distinct() %>%  
group_by(Bioregion) %>% 
summarise(Bioregion_count = n()) %>% 
mutate(Group = "Bioregion") %>% 
rename(Habitat_bioregion = Bioregion) %>% 
rename(Count = Bioregion_count)


c = bind_rows(habitat, bioregion)

ggplot(c, aes(Habitat_bioregion, Count)) +
geom_col(fill = "gray25",width = 0.9, color="black", linewidth = 0.4) +
theme_bw()+
coord_flip(expand = F) +
ggforce::facet_col(~ factor(Group, levels=c("Habitat","Bioregion")),
        space = "free", scales = "free_y") +
ylab("Sampling sites") +
xlab(NULL) +
theme(plot.margin=unit(c(0,0,0,0), "mm"),
      axis.ticks.x = element_line(color="black"),
      strip.text.x = element_text(size=14, face = "bold"),
      strip.background = element_rect(size=0.5, linetype="solid"),
  axis.title = element_text(face = "bold", size = 14),
axis.text = element_text(size=10))


```


```{r echo=FALSE, message=FALSE, cache=FALSE, warning=FALSE, out.width="60%", fig.cap= "\\textbf{Figure S3}. Association between nestedness (NODFc) and the geometric mean of plan and pollinator species per network", fig.width=3, fig.height=3}


metrics_by_network_spp_number = readRDS("../Data/Working_files/metrics_by_network_spp_number.rds")

metrics_by_network_spp_number %>% 
ggplot(aes(geometric_mean_spp, Normalised_nestedness)) +
geom_point(pch = 21, fill = "azure3", size=1.5, stroke=0.25, alpha=1) +
theme_bw() +
xlab("Species") +
ylab("Normalised nestedness (NODFc)") +
theme(
    axis.title = element_text(face = "bold", size = 10),
    axis.text = element_text(size = 8))


```